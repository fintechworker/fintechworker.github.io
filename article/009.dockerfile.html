<!DOCTYPE html>
<html lang="zh">
<head>
<!-- head--->
    
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
    <meta charset="UTF-8">
	<meta name="keywords" content="IT,Linux,Docker,K8S,网络, Java, Python, XHTML, JavaScript">
	<meta name="keywords" content="IT民工,IT Worker">
	<meta name="description" content="IT技术分享">
    <!-- libs css-->
    <link rel="stylesheet" href="/_assets/css/bootstrap.css">
    <link rel="stylesheet" href="/_assets/css/tool.css">
    <!-- libs js -->
    <script src="/_assets/js/jquery-1.8.2.min.js"></script>
    <script src="/_assets/js/jquery.ba-hashchange.js"></script>
    <!--<script src="/_assets/js/onePage.js"></script>-->
    <script src="/_assets/js/tool.js"></script>
    <script src="/_assets/js/base.js"></script>
    <!-- style -->
    <link rel="stylesheet" href="/_assets/style.css">
    <link rel="stylesheet" href="/_assets/css/media.css">
	<meta name="keywords" content="Dockerfile指令详解">
    <title>Dockerfile指令详解-IT民工</title>
<link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
<body>
<!-- 头部 -->
<div class="header">
    <div class="container header-all phone">
        <div class="logo"><a href="/index.html"><img src="/_assets/images/logo.png"/></a></div>
        <div class="phone-show" id="phone-show">
            <div></div>
            <div></div>
            <div></div>
        </div>
        <ul class="nav" id="header-nav">
		
		
		
          <li><a href="/index.html"><i class="iconfont">&#xe6cb;</i>首页</a></li>
        
		
          <li><a href="/archives.html"><i class="iconfont">&#xe690;</i>归档</a></li>
        
		
          <li><a href="/about.html"><i class="iconfont">&#xe69e;</i>关于</a></li>
        
		 
		
          <li><a href="/rss.xml"><i class="iconfont">&#xe6cb;</i>RSS</a></li>
          
	           
        </ul>
    </div>
</div>
<t></t>

<!-- 内容 -->
<div class="content container" data-content>
    <!-- 一级 -->
					
    <ul class="list row bj-white" id="list-1">
        <li class="title">
            <i class="iconfont c-hong">&#xe940;</i>热门推介<label>欢迎访问IT民工的网站！</label>
        </li>
        <div>
            <li class="cont-req">
                <a class="t1_pick"><img src="/_assets/images/header-img-1.jpg"/></a>
				
					<h3><a href="/article/cloudflare-vercel.html" >解决使用Cloudflare加速vercel“您的连接不是私密连接”问题解决</a></h3>

				
            </li>
            <li class="cont-req">
                <a class="t1_pick"><img src="/_assets/images/header-img-2.jpg"/></a>
				
					<h3><a href="/article/009.dockerfile.html" >Dockerfile指令详解</a></h3>
				
            </li>
            <li class="cont-req">
                <a class="t1_pick"><img src="/_assets/images/header-img-3.jpg"/></a>
				
					<h3><a href="/article/008.dockerfile.html" >Dockerfile 哪些命令会构建新的镜像层</a></h3>
				
            </li>
            <li class="cont-req">
                <a class="t1_pick"><img src="/_assets/images/header-img-4.jpg"/></a>
				
					<h3><a href="/article/007.-dockerfile.html" >使用 Dockerfile 定制镜像</a></h3>
				
				
            </li>
            <li class="cont-req">
                <a class="t1_pick"><img src="/_assets/images/header-img-5.jpg"/></a>
				
					<h3><a href="/article/006.docker.html" >Docker命令</a></h3>
				
				
            </li>
        </div>
    </ul>
    <!-- 二级 -->
    <div class="love2" >

        <div class="left">
            <!-- 文章主体 -->
            <div class="contents">
                <div class="title">Dockerfile指令详解</div>
                <div class="title_t">时间：2024-02-05 16:47丨编辑：<a href="/index.html">IT民工</a></div>
                <div class="ner">
                  <h1 id="1copy-复制文件">1.COPY 复制文件</h1>
<p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。<br />
<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：<br />
<code>COPY package.json /usr/src/app/`` </code>&lt;源路径&gt;<code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [</code>filepath.Match`]规则，如：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。<br />
在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">55</span>:mygroup files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=bin files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">1</span> files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">10</span>:<span class="hljs-number">11</span> files* <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h1 id="2add-更高级的复制文件">2.ADD 更高级的复制文件</h1>
<p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。<br />
比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。<br />
如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。<br />
在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> scratch
<span class="hljs-built_in">ADD</span> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /
<span class="hljs-built_in">..</span>.</code></pre></div>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a title="https://yeasy.gitbook.io/docker_practice/appendix/best_practices" href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=55:mygroup files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=bin files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=1 files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=10:11 files* /mydir/</code></pre></div>
<h1 id="3cmd-容器启动命令">3.CMD 容器启动命令</h1>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></li>
<li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<p><code>CMD echo $HOME</code></p>
<p>在实际执行中，会将其变更为：</p>
<p><code>CMD [ "sh", "-c", "echo $HOME" ]</code></p>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。<br />
Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<p>CMD service nginx start</p>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 init 系统以后台守护进程的形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<p><code>CMD ["nginx", "-g", "daemon off;"]</code></p>
<h1 id="4entrypoint-入口点">4.ENTRYPOINT 入口点</h1>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。<br />
<code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。<br />
当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：<br />
<code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code><br />
那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处么？让我们来看几个场景。</p>
<h3 id="场景一让镜像变成像命令一样使用">场景一：让镜像变成像命令一样使用</h3>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
CMD [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：<br />
<code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> myip -i
docker: <span class="hljs-built_in">Error</span> response <span class="hljs-keyword">from</span> daemon: invalid header field value <span class="hljs-string">"oci runtime error: container_linux.go:247: starting container process caused \\"</span>exec: \\\\\<span class="hljs-string">"-i\\\\\": executable file not found in <span class="hljs-variable">$PATH</span>\\"</span>\\n<span class="hljs-string">".</span></code></pre></div>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<p>`$ docker run myip curl  -s <a title="http://myip.ipip.net" href="http://myip.ipip.net">http://myip.ipip.net</a> -i</p>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
ENTRYPOINT [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<p><code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<div><pre class="hljs"><code>$ docker run myip -i
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-keyword">Server</span>: nginx/<span class="hljs-number">1.8</span><span class="hljs-number">.0</span>
<span class="hljs-type">Date</span>: Tue, <span class="hljs-number">22</span> Nov <span class="hljs-number">2016</span> <span class="hljs-number">05</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40</span> GMT
Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; 
 charset=UTF<span class="hljs-number">-8</span>
Vary: Accept-<span class="hljs-keyword">Encoding</span>
X-Powered-<span class="hljs-keyword">By</span>: PHP/<span class="hljs-number">5.6</span><span class="hljs-number">.24</span><span class="hljs-number">-1</span>~dotdeb+<span class="hljs-number">7.1</span>
X-<span class="hljs-keyword">Cache</span>: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>
X-<span class="hljs-keyword">Cache</span>-Lookup: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>
X-<span class="hljs-keyword">Cache</span>: MISS from proxy<span class="hljs-number">-2</span>_6
Transfer-<span class="hljs-keyword">Encoding</span>: chunked
Via: <span class="hljs-number">1.1</span> <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>, <span class="hljs-number">1.1</span> proxy<span class="hljs-number">-2</span>_6:<span class="hljs-number">8006</span>
<span class="hljs-keyword">Connection</span>: keep-alive</code></pre></div>
<p>当前 IP：61.148.226.66 来自：北京市 联通<br />
可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h3 id="场景二应用运行前的准备工作">场景二：应用运行前的准备工作</h3>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。<br />
比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。<br />
此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。<br />
这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.4</span>
...
<span class="hljs-keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span>
...
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"docker-entrypoint.sh"</span>]</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6379</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"redis-server"</span> ]</span></code></pre></div>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/sh</span>
...
<span class="hljs-comment"># allow the container to be started with `--user`</span>
<span class="hljs-keyword">if</span> [  <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>  =  <span class="hljs-string">'redis-server'</span>  -a  <span class="hljs-string">"<span class="hljs-subst">$(id  -u)</span>"</span>  =  <span class="hljs-string">'0'</span> ]; <span class="hljs-keyword">then</span>
    find . \!  -user redis -<span class="hljs-built_in">exec</span>  chown redis <span class="hljs-string">'{}'</span> +<span class="hljs-built_in">exec</span> gosu redis <span class="hljs-string">"<span class="hljs-variable">$0</span>"</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">exec</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span></code></pre></div>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> -it redis id
<span class="hljs-attribute">uid</span>=0(root)  <span class="hljs-attribute">gid</span>=0(root)  <span class="hljs-attribute">groups</span>=0(root)</code></pre></div>
<h1 id="5env-设置环境变量">5.ENV 设置环境变量</h1>
<p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<div><pre class="hljs"><code>ENV <span class="hljs-attribute">VERSION</span>=1.0 <span class="hljs-attribute">DEBUG</span>=on \
        <span class="hljs-attribute">NAME</span>=<span class="hljs-string">"Happy Feet"</span></code></pre></div>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。<br />
定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<div><pre class="hljs"><code>ENV NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span>
RUN curl -SLO https://nodejs.org/dist/v$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION</span>/<span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION-linux-x64</span>.tar.xz<span class="hljs-string">"  \
  	  &amp;&amp; curl -SLO "</span>https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc<span class="hljs-string">" \
    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
    &amp;&amp; grep "</span> <span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz\\$<span class="hljs-string">" SHASUMS256.txt | sha256sum -c - \
    &amp;&amp; tar -xJf "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" -C /usr/local --strip-components=1 \
    &amp;&amp; rm "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" SHASUMS256.txt.asc SHASUMS256.txt \
    &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span></code></pre></div>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。<br />
可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h1 id="6arg-构建参数">6.ARG 构建参数</h1>
<p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p>
<p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<div><pre class="hljs"><code>ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p>
<div><pre class="hljs"><code><span class="hljs-comment"># 只在 FROM 中生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 要想在 FROM 之后使用，必须再次指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
对于多阶段构建，尤其要注意这个问题

<span class="hljs-comment"># 这个变量在每个 FROM 中都生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 1
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 2
对于上述 Dockerfile 两个 <span class="hljs-keyword">FROM</span> 指令都可以使用<span class="hljs-variable">${DOCKER_USERNAME}</span>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<h1 id="7volume-定义匿名卷">7.VOLUME 定义匿名卷</h1>
<p>格式为：</p>
<ul>
<li><code>VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。<br />
<code>VOLUME /data</code></p>
<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p>
<div><pre class="hljs"><code>$ docker run -d  -v mydata:/<span class="hljs-class"><span class="hljs-keyword">data</span> xxxx</span></code></pre></div>
<h1 id="8expose-暴露端口">8.EXPOSE 暴露端口</h1>
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h1 id="9workdir-指定工作目录">9.WORKDIR 指定工作目录</h1>
<p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span></code></pre></div>
<p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p>
<h1 id="10user-指定当前用户">10.USER 指定当前用户</h1>
<p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">RUN</span> groupadd -r redis &amp;&amp; useradd -r -g redis redis<span class="hljs-built_in">
USER </span>redis
<span class="hljs-built_in">RUN</span> [ <span class="hljs-string">"redis-server"</span> ]</code></pre></div>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a title="https://github.com/tianon/gosu" href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<div><pre class="hljs"><code><span class="hljs-comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span>
RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
<span class="hljs-comment"># 下载 gosu</span>
RUN wget -O <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu <span class="hljs-string">"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64"</span>  \
    &amp;&amp; chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu \
    &amp;&amp; gosu nobody true
<span class="hljs-comment"># 设置 CMD，并以另外的用户执行</span>
CMD \[ <span class="hljs-string">"exec"</span>, <span class="hljs-string">"gosu"</span>, <span class="hljs-string">"redis"</span>, <span class="hljs-string">"redis-server"</span> \]</code></pre></div>
<h1 id="11healthcheck-健康检查">11.HEALTHCHECK 健康检查</h1>
<p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li>
<p><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</p>
</li>
<li>
<p><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p>
</li>
<li>
<p><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</p>
</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<div><pre class="hljs"><code>FROM nginx

RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
HEALTHCHECK  --interval=<span class="hljs-number">5</span>s  --timeout=<span class="hljs-number">3</span>s  \
    CMD curl -fs http:<span class="hljs-regexp">//</span>localhost/ || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span></code></pre></div>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker build</code> 来构建这个镜像：</p>
<p><code>$ docker build -t myweb:v1 .</code></p>
<p>构建好了后，我们启动一个容器：<br />
``$ docker run -d  --name web -p  80:80 myweb:v1`</p>
<p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<div><pre class="hljs"><code><span class="language-xml">$ docker inspect --format  '</span><span class="hljs-template-variable">{{<span class="hljs-name">json</span> .State.Health}}</span><span class="language-xml">' web | python -m json.tool</span></code></pre></div>
<h1 id="12onbuild-为他人作嫁衣裳">12.ONBUILD 为他人作嫁衣裳</h1>
<p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br />
<code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。<br />
假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p>
<div><pre class="hljs"><code>FROM node:slim
<span class="hljs-keyword">RUN</span> <span class="hljs-keyword">mkdir</span> /<span class="hljs-keyword">app</span>
WORKDIR /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">COPY</span> ./package.json /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">RUN</span> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . /<span class="hljs-keyword">app</span>/
CMD [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</code></pre></div>
<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。<br />
如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。<br />
那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> my-node
<span class="hljs-keyword">COPY</span> .<span class="hljs-regexp">/package.json /</span>app
RUN [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . <span class="hljs-regexp">/app/</span></code></pre></div>
<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。<br />
那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。<br />
<code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">ONBUILD</span> 
<span class="hljs-keyword">COPY</span><span class="language-bash"> ./package.json /app</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">RUN</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">COPY</span><span class="language-bash"> . /app/</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<div><pre class="hljs"><code>FROM my-<span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h1 id="13label-为镜像添加元数据">13.LABEL 为镜像添加元数据</h1>
<p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。<br />
LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br />
我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<div><pre class="hljs"><code>LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.authors=<span class="hljs-string">"yeasy"</span>
LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.documentation=<span class="hljs-string">"https://yeasy.gitbooks.io"</span></code></pre></div>
<p>具体可以参考 <a title="https://github.com/opencontainers/image-spec/blob/master/annotations.md" href="https://github.com/opencontainers/image-spec/blob/master/annotations.md">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p>
<h1 id="14shell-指令">14.SHELL 指令</h1>
<p>格式：<code>SHELL ["executable", "parameters"]</code><br />
<code>SHELL</code> 指令可以指定 <code>RUN</code><br />
<code>ENTRYPOINT</code><br />
<code>CMD</code> 指令的 shell，Linux 中默认为 <code>["/bin/sh", "-c"]</code></p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span>
<span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span></code></pre></div>
<p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p>
<p>当 <code>ENTRYPOINT</code></p>
<p><code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span>
<span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> nginx</span></code></pre></div>

                </div>
				<div style="padding:15px;">
				   <a href="javascript:;">
						
							标签: 
									<span >docker</span>
									
									<span >dockerfile</span>
									
						</a>
				</div>
                <div class="label"> 转载请注明出处！--- IT民工 </div>
               
            </div>           
        </div>
	<!----侧边栏 --->
	        <div class="right" id="list-right">
            <!-- 关于我 -->
            <div class="thisMe">
                <div class="touPick">
				<img src="/_assets/images/aboutme.jpg" alt="图片走丢了" title="IT民工"></div>
				<ul>
                    <li><b style="font-size:20px;">IT民工</b></li>
                </ul>
				<br>
                <ul>
                    <li><a href="/index.html" style="text-decoration:none;" title="主页" class="iconfont">&#xe619;</a></li>
                    <li><a target="_blank" href="mailto:dliangliang@cock.li" title="联系我" style="text-decoration:none;" class="iconfont">&#xe667;</a></li>
                    <li><a href="/about.html" style="text-decoration:none;" title="关于我" class="iconfont">&#xe645;</a></li>
                </ul>
            </div>
            <!-- 建站史 -->
            <div class="ku">
                <div class="title">建站史</div>
                <div class="shus">
                    <div class="line"></div>
                    <div class="shus-cont">
                        <a>Joplin</a><br>
                        <a>MarkDown</a><br>
                        <a>Pages Publisher</a><br>
                        <a>GitHub Pages</a><br>
                        <a>Cloudflare Pages</a><br>
                        <a>Vercel Project</a><br>
                        <a href="javascript:;" class="href-all">查看全部</a>
                    </div>
                </div>
            </div>
   
            <!-- 标签云 -->
            <div class="labels" id="labels">
                <div class="title">标签云</div>
                <a>打工狗</a>
                <a>代码奴</a>
                <a>金融嗜好</a>
                <a>X瘾患者</a>
                <a>偶尔撸B</a>
                <a>精分患者</a>
                <a>软肋不少</a>
                <a>喜历史</a>
            </div>
            <!-- 友情链接 -->
            <div class="ku">
                <div class="title">左邻右舍</div>
                <div class="neighbor">
                    <a target="_blank" href="https://www.zhihu.com/people/economicsshare" title="知乎：巴甫洛夫的实验">知乎：巴甫洛夫的实验</a>
                    <a target="_blank" href="https://space.bilibili.com/18059632" title="B站：巴甫洛夫的实验">B站：巴甫洛夫的实验</a>
                    <a target="_blank" href="https://author.baidu.com/home?from=bjh_article&app_id=1790832269223398" title="百家号：巴甫洛夫的实验">百家号：巴甫洛夫的实验</a>                  
                    <a target="_blank" href="https://fintechworker.20160808.xyz" title="IT民工 On Cloudflare">IT民工&nbsp;On&nbsp;Cloudflare</a>                  
                    <a target="_blank" href="https://fintechworker.github.io" title="IT民工 On GitHub">IT民工&nbsp;On&nbsp;GitHub</a>                  
                    <a target="_blank" href="https://fintechworker-github-io.vercel.app" title="IT民工 On Vercel">IT民工&nbsp;On&nbsp;Vercel</a>                  
                
				</div>
            </div>
			 <!-- 建站史 -->
            <div class="ku" style="height:300px;">
                <div class="title">有点懒啊！</div>
                <div class="neighbor" >
他有点懒啊！
				</div>
            </div>
        </div>

    </div>
</div>
<!-- 底部 -->
<div class="footer">
    Design by <a href="#">IT民工</a>
    <br>&copy; <script> document.write(new Date().getFullYear()); </script> <a href="#">IT民工</a>
</div>

<!-- 侧边栏 -->

<div class="ce">
    <a class="ceL" href="#" title="返回顶部"><i class="iconfont top">&#xe65b;</i></a>
</div>


</body>
</html>
