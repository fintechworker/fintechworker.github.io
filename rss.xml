<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Mon, 26 Feb 2024 03:22:42 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[Dockerfile指令详解]]></title>
            <guid>f9a74c05fb8849a5b41bb73e21abbb6a</guid>
            <pubDate>Mon, 05 Feb 2024 08:47:45 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="1copy-复制文件">1.COPY 复制文件</h1>
<p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。<br />
<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：<br />
<code>COPY package.json /usr/src/app/`` </code>&lt;源路径&gt;<code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [</code>filepath.Match`]规则，如：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。<br />
在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">55</span>:mygroup files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=bin files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">1</span> files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">10</span>:<span class="hljs-number">11</span> files* <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h1 id="2add-更高级的复制文件">2.ADD 更高级的复制文件</h1>
<p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。<br />
比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。<br />
如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。<br />
在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> scratch
<span class="hljs-built_in">ADD</span> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /
<span class="hljs-built_in">..</span>.</code></pre></div>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a title="https://yeasy.gitbook.io/docker_practice/appendix/best_practices" href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=55:mygroup files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=bin files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=1 files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=10:11 files* /mydir/</code></pre></div>
<h1 id="3cmd-容器启动命令">3.CMD 容器启动命令</h1>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></li>
<li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<p><code>CMD echo $HOME</code></p>
<p>在实际执行中，会将其变更为：</p>
<p><code>CMD [ "sh", "-c", "echo $HOME" ]</code></p>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。<br />
Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<p>CMD service nginx start</p>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 init 系统以后台守护进程的形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<p><code>CMD ["nginx", "-g", "daemon off;"]</code></p>
<h1 id="4entrypoint-入口点">4.ENTRYPOINT 入口点</h1>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。<br />
<code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。<br />
当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：<br />
<code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code><br />
那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处么？让我们来看几个场景。</p>
<h3 id="场景一让镜像变成像命令一样使用">场景一：让镜像变成像命令一样使用</h3>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
CMD [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：<br />
<code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> myip -i
docker: <span class="hljs-built_in">Error</span> response <span class="hljs-keyword">from</span> daemon: invalid header field value <span class="hljs-string">"oci runtime error: container_linux.go:247: starting container process caused \\"</span>exec: \\\\\<span class="hljs-string">"-i\\\\\": executable file not found in <span class="hljs-variable">$PATH</span>\\"</span>\\n<span class="hljs-string">".</span></code></pre></div>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<p>`$ docker run myip curl  -s <a title="http://myip.ipip.net" href="http://myip.ipip.net">http://myip.ipip.net</a> -i</p>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
ENTRYPOINT [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<p><code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<div><pre class="hljs"><code>$ docker run myip -i
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-keyword">Server</span>: nginx/<span class="hljs-number">1.8</span><span class="hljs-number">.0</span>
<span class="hljs-type">Date</span>: Tue, <span class="hljs-number">22</span> Nov <span class="hljs-number">2016</span> <span class="hljs-number">05</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40</span> GMT
Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; 
 charset=UTF<span class="hljs-number">-8</span>
Vary: Accept-<span class="hljs-keyword">Encoding</span>
X-Powered-<span class="hljs-keyword">By</span>: PHP/<span class="hljs-number">5.6</span><span class="hljs-number">.24</span><span class="hljs-number">-1</span>~dotdeb+<span class="hljs-number">7.1</span>
X-<span class="hljs-keyword">Cache</span>: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>
X-<span class="hljs-keyword">Cache</span>-Lookup: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>
X-<span class="hljs-keyword">Cache</span>: MISS from proxy<span class="hljs-number">-2</span>_6
Transfer-<span class="hljs-keyword">Encoding</span>: chunked
Via: <span class="hljs-number">1.1</span> <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>, <span class="hljs-number">1.1</span> proxy<span class="hljs-number">-2</span>_6:<span class="hljs-number">8006</span>
<span class="hljs-keyword">Connection</span>: keep-alive</code></pre></div>
<p>当前 IP：61.148.226.66 来自：北京市 联通<br />
可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h3 id="场景二应用运行前的准备工作">场景二：应用运行前的准备工作</h3>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。<br />
比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。<br />
此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。<br />
这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.4</span>
...
<span class="hljs-keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span>
...
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"docker-entrypoint.sh"</span>]</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6379</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"redis-server"</span> ]</span></code></pre></div>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/sh</span>
...
<span class="hljs-comment"># allow the container to be started with `--user`</span>
<span class="hljs-keyword">if</span> [  <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>  =  <span class="hljs-string">'redis-server'</span>  -a  <span class="hljs-string">"<span class="hljs-subst">$(id  -u)</span>"</span>  =  <span class="hljs-string">'0'</span> ]; <span class="hljs-keyword">then</span>
    find . \!  -user redis -<span class="hljs-built_in">exec</span>  chown redis <span class="hljs-string">'{}'</span> +<span class="hljs-built_in">exec</span> gosu redis <span class="hljs-string">"<span class="hljs-variable">$0</span>"</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">exec</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span></code></pre></div>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> -it redis id
<span class="hljs-attribute">uid</span>=0(root)  <span class="hljs-attribute">gid</span>=0(root)  <span class="hljs-attribute">groups</span>=0(root)</code></pre></div>
<h1 id="5env-设置环境变量">5.ENV 设置环境变量</h1>
<p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<div><pre class="hljs"><code>ENV <span class="hljs-attribute">VERSION</span>=1.0 <span class="hljs-attribute">DEBUG</span>=on \
        <span class="hljs-attribute">NAME</span>=<span class="hljs-string">"Happy Feet"</span></code></pre></div>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。<br />
定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<div><pre class="hljs"><code>ENV NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span>
RUN curl -SLO https://nodejs.org/dist/v$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION</span>/<span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION-linux-x64</span>.tar.xz<span class="hljs-string">"  \
  	  &amp;&amp; curl -SLO "</span>https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc<span class="hljs-string">" \
    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
    &amp;&amp; grep "</span> <span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz\\$<span class="hljs-string">" SHASUMS256.txt | sha256sum -c - \
    &amp;&amp; tar -xJf "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" -C /usr/local --strip-components=1 \
    &amp;&amp; rm "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" SHASUMS256.txt.asc SHASUMS256.txt \
    &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span></code></pre></div>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。<br />
可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h1 id="6arg-构建参数">6.ARG 构建参数</h1>
<p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p>
<p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<div><pre class="hljs"><code>ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p>
<div><pre class="hljs"><code><span class="hljs-comment"># 只在 FROM 中生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 要想在 FROM 之后使用，必须再次指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
对于多阶段构建，尤其要注意这个问题

<span class="hljs-comment"># 这个变量在每个 FROM 中都生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 1
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 2
对于上述 Dockerfile 两个 <span class="hljs-keyword">FROM</span> 指令都可以使用<span class="hljs-variable">${DOCKER_USERNAME}</span>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<h1 id="7volume-定义匿名卷">7.VOLUME 定义匿名卷</h1>
<p>格式为：</p>
<ul>
<li><code>VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。<br />
<code>VOLUME /data</code></p>
<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p>
<div><pre class="hljs"><code>$ docker run -d  -v mydata:/<span class="hljs-class"><span class="hljs-keyword">data</span> xxxx</span></code></pre></div>
<h1 id="8expose-暴露端口">8.EXPOSE 暴露端口</h1>
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h1 id="9workdir-指定工作目录">9.WORKDIR 指定工作目录</h1>
<p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span></code></pre></div>
<p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p>
<h1 id="10user-指定当前用户">10.USER 指定当前用户</h1>
<p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">RUN</span> groupadd -r redis &amp;&amp; useradd -r -g redis redis<span class="hljs-built_in">
USER </span>redis
<span class="hljs-built_in">RUN</span> [ <span class="hljs-string">"redis-server"</span> ]</code></pre></div>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a title="https://github.com/tianon/gosu" href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<div><pre class="hljs"><code><span class="hljs-comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span>
RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
<span class="hljs-comment"># 下载 gosu</span>
RUN wget -O <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu <span class="hljs-string">"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64"</span>  \
    &amp;&amp; chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu \
    &amp;&amp; gosu nobody true
<span class="hljs-comment"># 设置 CMD，并以另外的用户执行</span>
CMD \[ <span class="hljs-string">"exec"</span>, <span class="hljs-string">"gosu"</span>, <span class="hljs-string">"redis"</span>, <span class="hljs-string">"redis-server"</span> \]</code></pre></div>
<h1 id="11healthcheck-健康检查">11.HEALTHCHECK 健康检查</h1>
<p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li>
<p><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</p>
</li>
<li>
<p><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p>
</li>
<li>
<p><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</p>
</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<div><pre class="hljs"><code>FROM nginx

RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
HEALTHCHECK  --interval=<span class="hljs-number">5</span>s  --timeout=<span class="hljs-number">3</span>s  \
    CMD curl -fs http:<span class="hljs-regexp">//</span>localhost/ || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span></code></pre></div>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker build</code> 来构建这个镜像：</p>
<p><code>$ docker build -t myweb:v1 .</code></p>
<p>构建好了后，我们启动一个容器：<br />
``$ docker run -d  --name web -p  80:80 myweb:v1`</p>
<p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<div><pre class="hljs"><code><span class="language-xml">$ docker inspect --format  '</span><span class="hljs-template-variable">{{<span class="hljs-name">json</span> .State.Health}}</span><span class="language-xml">' web | python -m json.tool</span></code></pre></div>
<h1 id="12onbuild-为他人作嫁衣裳">12.ONBUILD 为他人作嫁衣裳</h1>
<p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br />
<code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。<br />
假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p>
<div><pre class="hljs"><code>FROM node:slim
<span class="hljs-keyword">RUN</span> <span class="hljs-keyword">mkdir</span> /<span class="hljs-keyword">app</span>
WORKDIR /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">COPY</span> ./package.json /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">RUN</span> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . /<span class="hljs-keyword">app</span>/
CMD [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</code></pre></div>
<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。<br />
如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。<br />
那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> my-node
<span class="hljs-keyword">COPY</span> .<span class="hljs-regexp">/package.json /</span>app
RUN [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . <span class="hljs-regexp">/app/</span></code></pre></div>
<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。<br />
那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。<br />
<code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">ONBUILD</span> 
<span class="hljs-keyword">COPY</span><span class="language-bash"> ./package.json /app</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">RUN</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">COPY</span><span class="language-bash"> . /app/</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<div><pre class="hljs"><code>FROM my-<span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h1 id="13label-为镜像添加元数据">13.LABEL 为镜像添加元数据</h1>
<p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。<br />
LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br />
我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<div><pre class="hljs"><code>LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.authors=<span class="hljs-string">"yeasy"</span>
LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.documentation=<span class="hljs-string">"https://yeasy.gitbooks.io"</span></code></pre></div>
<p>具体可以参考 <a title="https://github.com/opencontainers/image-spec/blob/master/annotations.md" href="https://github.com/opencontainers/image-spec/blob/master/annotations.md">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p>
<h1 id="14shell-指令">14.SHELL 指令</h1>
<p>格式：<code>SHELL ["executable", "parameters"]</code><br />
<code>SHELL</code> 指令可以指定 <code>RUN</code><br />
<code>ENTRYPOINT</code><br />
<code>CMD</code> 指令的 shell，Linux 中默认为 <code>["/bin/sh", "-c"]</code></p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span>
<span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span></code></pre></div>
<p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p>
<p>当 <code>ENTRYPOINT</code></p>
<p><code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span>
<span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> nginx</span></code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Dockerfile 哪些命令会构建新的镜像层]]></title>
            <guid>ffdd163ce89e449f891380e816e1b54f</guid>
            <pubDate>Mon, 05 Feb 2024 08:44:53 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="dockerfile-哪些命令会构建新的镜像层">Dockerfile: 哪些命令会构建新的镜像层</h2>
<h3 id="导语">导语</h3>
<p>在使用 Docker 进行容器化应用部署时，Dockerfile 是非常重要的一环。Dockerfile 是一个用于构建 Docker 镜像的文件，通过在 Dockerfile 中定义一系列的命令，我们可以自动化地构建、配置和部署容器化应用。在 Dockerfile 中，有一些特定的命令会导致 Docker 构建新的镜像层。本文将介绍这些命令，并提供相应的代码示例。</p>
<h3 id="1-dockerfile-简介">1. Dockerfile 简介</h3>
<p>Dockerfile 是一个文本文件，其中包含了一系列用于构建 Docker 镜像的命令。通过 Dockerfile，我们可以定义从基础镜像到最终镜像的构建过程，并指定容器运行时的配置。使用 Dockerfile 可以实现自动化、可重复的镜像构建流程。</p>
<h3 id="2-dockerfile-构建新的镜像层的命令">2. Dockerfile 构建新的镜像层的命令</h3>
<h4 id="21-from">2.1 FROM</h4>
<p><code>FROM</code> 命令用于指定基础镜像。在 Dockerfile 中，通常以 <code>FROM</code> 开头。当 Docker 构建镜像时，会从 Docker Hub 或本地镜像仓库拉取指定的基础镜像，并在其基础上构建新的镜像层。</p>
<p>以下是一个使用 <code>FROM</code> 命令的示例：</p>
<p>上述示例中，我们指定了基础镜像为最新版本的 Ubuntu。</p>
<h4 id="22-run"><a id="22_RUN_24" class="jop-noMdConv"></a>2.2 RUN</h4>
<p><code>RUN</code> 命令用于在容器中执行一条或多条命令，并将结果保存为新的镜像层。可以在 <code>RUN</code> 命令中执行任何可以在容器内部执行的命令，例如安装软件包、运行脚本等。每个 <code>RUN</code> 命令都会在当前镜像层的基础上生成一个新的镜像层。</p>
<p>以下是一个使用 <code>RUN</code> 命令的示例：</p>
<p>上述示例中，我们使用 <code>RUN</code> 命令更新了软件包列表，并安装了 Nginx。</p>
<h4 id="23-copy"><a id="23_COPY_36" class="jop-noMdConv"></a>2.3 COPY</h4>
<p><code>COPY</code> 命令用于将文件或目录从构建上下文复制到镜像中。每个 <code>COPY</code> 命令都会在当前镜像层的基础上生成一个新的镜像层。</p>
<p>以下是一个使用 <code>COPY</code> 命令的示例：</p>
<p>上述示例中，我们将 <code>app.jar</code> 文件复制到镜像的 <code>/app/</code> 目录下。</p>
<h4 id="24-add"><a id="24_ADD_48" class="jop-noMdConv"></a>2.4 ADD</h4>
<p><code>ADD</code> 命令功能类似于 <code>COPY</code> 命令，但是在复制文件或目录的同时，还支持自动解压缩和远程文件下载。每个 <code>ADD</code> 命令也会在当前镜像层的基础上生成一个新的镜像层。</p>
<p>以下是一个使用 <code>ADD</code> 命令的示例：</p>
<p>上述示例中，我们将远程的 <code>file.tar.gz</code> 文件下载并解压缩到镜像的 <code>/data/</code> 目录下。</p>
<h4 id="25-cmd"><a id="25_CMD_60" class="jop-noMdConv"></a>2.5 CMD</h4>
<p><code>CMD</code> 命令用于指定容器启动时要执行的命令。每个 Dockerfile 只能有一个 <code>CMD</code> 命令，如果有多个 <code>CMD</code> 命令，则只有最后一个有效。<code>CMD</code> 命令在创建容器时被指定为容器的默认命令，可以在运行容器时覆盖。</p>
<p>以下是一个使用 <code>CMD</code> 命令的示例：</p>
<p>上述示例中，我们指定了容器启动时要执行的命令为 <code>java -jar app.jar</code>。</p>
<h4 id="26-entrypoint">2.6 ENTRYPOINT</h4>
<p><code>ENTRYPOINT</code> 命令也用于指定容器启动时要执行的命令。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Dockerfile 定制镜像]]></title>
            <guid>85438dc178f744db80cf03f114b9bc0d</guid>
            <pubDate>Mon, 05 Feb 2024 08:12:36 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="1from-指定基础镜像">1.FROM 指定基础镜像</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> nginx
RUN echo <span class="hljs-string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html</code></pre></div>
<p>Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<div><pre class="hljs"><code>FROM scratch
<span class="hljs-meta">...</span></code></pre></div>
<h3 id="2run-执行命令">2.RUN 执行命令</h3>
<p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</li>
</ul>
<div><pre class="hljs"><code>RUN echo <span class="hljs-string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html</code></pre></div>
<ul>
<li>exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。</li>
</ul>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。<br />
上面的 Dockerfile 正确的写法应该是这样：</p>
<div><pre class="hljs"><code>FROM debian:stretch

RUN set -x; buildDeps=<span class="hljs-string">'gcc libc6-dev make wget'</span> \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \
    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \
    &amp;&amp; mkdir -p <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C <span class="hljs-regexp">/usr/</span>src/redis --strip-components=<span class="hljs-number">1</span> \
    &amp;&amp; make -C <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; make -C <span class="hljs-regexp">/usr/</span>src/redis install \
    &amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></code></pre></div>
<p>Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。<br />
此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h3 id="3构建镜像">3.构建镜像</h3>
<p>docker build [选项] &lt;上下文路径/URL/-&gt;<br />
<code>docker build -t nginx:v3 .</code></p>
<h3 id="4镜像构建上下文context">4.镜像构建上下文（Context）</h3>
<p>如果注意，会看到 docker build 命令最后有一个<code> .</code>。<code>.</code> 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？<br />
首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<br />
当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？<br />
这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。<br />
如果在 Dockerfile 中这么写：<br />
<code>COPY ./package.json /app/</code><br />
这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。<br />
因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。<br />
现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。<br />
如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">build </span>-t nginx:v3 .
Sending <span class="hljs-keyword">build </span><span class="hljs-built_in">context</span> to Docker daemon <span class="hljs-number">2</span>.<span class="hljs-number">048</span> kB
...</code></pre></div>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。<br />
一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。<br />
那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。<br />
这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用<code> -f ../Dockerfile.php</code> 参数指定某个文件作为 Dockerfile。<br />
当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docker命令]]></title>
            <guid>77c28c4bfc5c4091a7f0aa3e30330811</guid>
            <pubDate>Mon, 05 Feb 2024 06:10:12 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="1获取镜像">1.获取镜像</h3>
<p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：<br />
<code>$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code><br />
具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。<br />
Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub(docker.io)。<br />
仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。<br />
比如：<br />
<code>$ docker pull ubuntu:18.04</code></p>
<h3 id="2运行镜像">2.运行镜像</h3>
<p><code>$ docker run -it --rm ubuntu:18.04 bash</code><br />
docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。<br />
-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br />
--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。<br />
ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。<br />
bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。<br />
进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。</p>
<h3 id="3列出镜像">3.列出镜像</h3>
<p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令</p>
<h3 id="4镜像体积">4.镜像体积</h3>
<p><code>$ docker system df</code></p>
<h3 id="5虚悬镜像">5.虚悬镜像</h3>
<p>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none class="jop-noMdConv"> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：<br />
<code>$ docker image ls -f dangling=true</code><br />
一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。<br />
<code>$ docker image prune</code></none></p>
<h3 id="6中间层镜像">6.中间层镜像</h3>
<p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。<br />
<code>$ docker image ls -a</code></p>
<h3 id="7列出部分镜像">7.列出部分镜像</h3>
<div><pre class="hljs"><code><span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> ubuntu
<span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> ubuntu:<span class="hljs-number">18.04</span>
<span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> <span class="hljs-operator">-f</span> since=mongo:<span class="hljs-number">3.2</span></code></pre></div>
<p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。<br />
此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。<br />
<code>$ docker image ls -f label=com.example.version=0.1</code></p>
<p>利用 docker image ls 把所有的虚悬镜像的 ID 列出来<br />
<code>$docker image ls -q</code></p>
<p>下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<div><pre class="hljs"><code><span class="hljs-string">$</span> <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">ls</span> <span class="hljs-string">--format</span> <span class="hljs-string">"<span class="hljs-template-variable">{{.ID}}</span>: <span class="hljs-template-variable">{{.Repository}}</span>"</span>
<span class="hljs-attr">5f515359c7f8:</span> <span class="hljs-string">redis</span>
<span class="hljs-attr">05a60462f8ba:</span> <span class="hljs-string">nginx</span>
<span class="hljs-attr">fe9198c04d62:</span> <span class="hljs-string">mongo</span>
<span class="hljs-attr">00285df0df87:</span> <span class="hljs-string">&lt;none&gt;</span>
<span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span>
<span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span></code></pre></div>
<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p>
<div><pre class="hljs"><code><span class="language-xml">$ docker image ls --format "table </span><span class="hljs-template-variable">{{<span class="hljs-name">.ID</span>}}</span><span class="language-xml">\t</span><span class="hljs-template-variable">{{<span class="hljs-name">.Repository</span>}}</span><span class="language-xml">\t</span><span class="hljs-template-variable">{{<span class="hljs-name">.Tag</span>}}</span><span class="language-xml">"
IMAGE ID            REPOSITORY          TAG
5f515359c7f8        redis               latest
05a60462f8ba        nginx               latest
fe9198c04d62        mongo               3.2
00285df0df87        <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>
329ed837d508        ubuntu              18.04
329ed837d508        ubuntu              bionic</span></code></pre></div>
<h3 id="8删除本地镜像">8.删除本地镜像</h3>
<p>如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：<br />
<code>$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></p>
<p><strong>用 docker image ls 命令来配合</strong><br />
像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。<br />
比如，我们需要删除所有仓库名为 redis 的镜像：<br />
<code>$ docker image rm $(docker image ls -q redis)</code><br />
或者删除所有在 mongo:3.2 之前的镜像：<br />
<code>$ docker image rm $(docker image ls -q -f before=mongo:3.2)</code></p>
<h3 id="9利用-commit-理解镜像构成">9.利用 commit 理解镜像构成</h3>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。<br />
docker commit 的语法格式为：<br />
docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]<br />
我们可以用下面的命令将容器保存为镜像：</p>
<div><pre class="hljs"><code>    --author <span class="hljs-string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> <span class="hljs-string">\</span>
    --message <span class="hljs-string">"修改了默认网页"</span> <span class="hljs-string">\</span>
    webserver <span class="hljs-string">\</span>
    nginx:v2
sha256:<span class="hljs-number">07e</span>33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</code></pre></div>
<p>其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。</p>
<h3 id="10exec-命令进入镜像">10.exec 命令进入镜像</h3>
<p>-i -t 参数<br />
docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。<br />
只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。<br />
当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。<br />
<code>$ docker run -dit ubuntu</code></p>
<h3 id="11导出容器">11.导出容器</h3>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。<br />
<code>$ docker container ls  -a</code><br />
<code>$ docker  export 7691a814370e &gt; ubuntu.tar</code><br />
这样将导出容器快照到本地文件。</p>
<h3 id="12导入容器快照">12.导入容器快照</h3>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如<br />
<code>$ cat ubuntu.tar |  docker  import - test/ubuntu:v1</code><br />
此外，也可以通过指定 URL 或者某个目录来导入，例如<br />
<code>$ docker  import http://example.com/exampleimage.tgz example/imagerepo</code><br />
<em>注：用户既可以使用</em> <code>docker load</code> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <code>docker import</code> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h3 id="13删除容器">13.删除容器</h3>
<p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如<br />
<code>$ docker container rm trusting_newton</code><br />
如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<h3 id="14清理所有处于终止状态的容器">14.清理所有处于终止状态的容器</h3>
<p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。<br />
<code>$ docker container prune</code></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Centos安装docker]]></title>
            <guid>aa1cd4c0f756490abd47ce04310b4d6e</guid>
            <pubDate>Sun, 04 Feb 2024 09:25:34 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="centos">CentOS</h2>
<p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p>
<h3 id="准备工作">准备工作</h3>
<p><strong>系统要求</strong><br />
Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br />
卸载旧版本<br />
旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<div><pre class="hljs"><code>                  docker-client <span class="hljs-string">\</span>
                  docker-client-latest <span class="hljs-string">\</span>
                  docker-common <span class="hljs-string">\</span>
                  docker-latest <span class="hljs-string">\</span>
                  docker-latest-logrotate <span class="hljs-string">\</span>
                  docker-logrotate <span class="hljs-string">\</span>
                  docker-selinux <span class="hljs-string">\</span>
                  docker-engine-selinux <span class="hljs-string">\</span>
                  docker-engine</code></pre></div>
<p>使用 yum 安装<br />
执行以下命令安装依赖包：<br />
<code>$ sudo yum install -y yum-utils</code><br />
鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。<br />
执行下面的命令添加 yum 软件源：</p>
<div><pre class="hljs"><code>$ sudo yum-config-manager \
    --add-repo \
    https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo
​
$ sudo sed -i <span class="hljs-string">'s/download.docker.com/mirrors.aliyun.com\/docker-ce/g'</span> <span class="hljs-regexp">/etc/yum</span>.repos.d/docker-ce.repo
​
<span class="hljs-comment"># 官方源</span>
<span class="hljs-comment"># $ sudo yum-config-manager \</span>
<span class="hljs-comment">#     --add-repo \</span>
<span class="hljs-comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></code></pre></div>
<p>如果需要测试版本的 Docker 请执行以下命令：<br />
<code>$ sudo yum-config-manager --enable docker-ce-test</code><br />
安装 Docker<br />
更新 yum 软件源缓存，并安装 docker-ce。<br />
<code>$ sudo yum install docker-ce docker-ce-cli containerd.io</code><br />
CentOS8 额外设置<br />
由于 CentOS8 防火墙使用了 nftables，但 Docker 尚未支持 nftables， 我们可以使用如下设置使用 iptables：<br />
更改 /etc/firewalld/firewalld.conf<br />
<code># FirewallBackend=nftables FirewallBackend=iptables 或者执行如下命令： $ firewall-cmd --permanent --zone=trusted --add-interface=docker0 ​ $ firewall-cmd --reload </code><br />
使用脚本自动安装<br />
在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装：<br />
若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p>
<div><pre class="hljs"><code><span class="hljs-comment"># $ curl -fsSL test.docker.com -o get-docker.sh</span>
$ <span class="hljs-string">curl</span> -<span class="hljs-string">fsSL</span> <span class="hljs-string">get</span>.<span class="hljs-string">docker</span>.<span class="hljs-string">com</span> -<span class="hljs-string">o</span> <span class="hljs-built_in">get-docker.sh</span>
$ <span class="hljs-string">sudo</span> <span class="hljs-string">sh</span> <span class="hljs-built_in">get-docker.sh</span> <span class="hljs-built_in">--mirror</span> <span class="hljs-string">Aliyun</span>
<span class="hljs-comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></code></pre></div>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。<br />
启动 Docker</p>
<div><pre class="hljs"><code><span class="hljs-variable">$</span> sudo systemctl enable docker
<span class="hljs-variable">$</span> sudo systemctl <span class="hljs-built_in">start</span> docker</code></pre></div>
<p>建立 docker 用户组<br />
默认情况下，docker 命令会使用  与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。<br />
建立 docker 组：<br />
<code>$ sudo groupadd docker</code><br />
将当前用户加入 docker 组：<br />
<code>$ sudo usermod -aG docker $USER</code><br />
退出当前终端并重新登录，进行如下测试。<br />
测试 Docker 是否安装正确</p>
<div><pre class="hljs"><code>$ docker run <span class="hljs-comment">--rm hello-world</span>
​
Unable <span class="hljs-built_in">to</span> find image <span class="hljs-string">'hello-world:latest'</span> locally
latest: Pulling <span class="hljs-built_in">from</span> library/hello-world
b8dfde127a29: Pull complete
Digest: sha256:<span class="hljs-number">308866</span>a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24
Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest
​
Hello <span class="hljs-built_in">from</span> Docker!
This message shows that your installation appears <span class="hljs-built_in">to</span> be working correctly.
​
To generate this message, Docker took <span class="hljs-keyword">the</span> following steps:
 <span class="hljs-number">1.</span> The Docker client contacted <span class="hljs-keyword">the</span> Docker daemon.
 <span class="hljs-number">2.</span> The Docker daemon pulled <span class="hljs-keyword">the</span> <span class="hljs-string">"hello-world"</span> image <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> Docker Hub.
    (amd64)
 <span class="hljs-number">3.</span> The Docker daemon created <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> container <span class="hljs-built_in">from</span> that image which runs <span class="hljs-keyword">the</span>
    executable that produces <span class="hljs-keyword">the</span> output you are currently reading.
 <span class="hljs-number">4.</span> The Docker daemon streamed that output <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Docker client, which sent <span class="hljs-keyword">it</span>
    <span class="hljs-built_in">to</span> your terminal.
​
To <span class="hljs-keyword">try</span> something more ambitious, you can run <span class="hljs-keyword">an</span> Ubuntu container <span class="hljs-keyword">with</span>:
 $ docker run -<span class="hljs-keyword">it</span> ubuntu bash
​
Share images, automate workflows, <span class="hljs-keyword">and</span> more <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> free Docker ID:
 <span class="hljs-keyword">https</span>://hub.docker.com/
​
For more examples <span class="hljs-keyword">and</span> ideas, visit:
 <span class="hljs-keyword">https</span>://docs.docker.com/<span class="hljs-built_in">get</span>-started/</code></pre></div>
<p>若能正常输出以上信息，则说明安装成功。<br />
镜像加速<br />
如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 。<br />
添加内核参数<br />
如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p>
<div><pre class="hljs"><code><span class="hljs-symbol">WARNING: </span>bridge-nf-call-iptables is disabled
<span class="hljs-symbol">WARNING: </span>bridge-nf-call-ip6tables is disabled</code></pre></div>
<p>请添加内核配置参数以启用这些功能。</p>
<div><pre class="hljs"><code>$ sudo tee -<span class="hljs-selector-tag">a</span> /etc/sysctl<span class="hljs-selector-class">.conf</span> &lt;&lt;-EOF
net<span class="hljs-selector-class">.bridge</span><span class="hljs-selector-class">.bridge-nf-call-ip6tables</span> = <span class="hljs-number">1</span>
net<span class="hljs-selector-class">.bridge</span><span class="hljs-selector-class">.bridge-nf-call-iptables</span> = <span class="hljs-number">1</span>
EOF</code></pre></div>
<p>然后重新加载 sysctl.conf 即可<br />
<code>$ sudo sysctl -p</code></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何修改docker0网桥地址]]></title>
            <guid>90fea9db360e45058218f13a6fc27016</guid>
            <pubDate>Tue, 23 Jan 2024 09:06:20 GMT</pubDate>
            <content:encoded><![CDATA[<p>第一步 删除原有配置：</p>
<div><pre class="hljs"><code>sudo<span class="hljs-built_in"> service </span>docker stop
sudo<span class="hljs-built_in"> ip </span>link <span class="hljs-built_in">set</span> dev docker0 down
sudo brctl delbr docker0
sudo iptables -t<span class="hljs-built_in"> nat </span>-F POSTROUTING</code></pre></div>
<p>第二步 创建新的网桥：</p>
<div><pre class="hljs"><code>sudo brctl addbr docker0
sudo<span class="hljs-built_in"> ip </span>addr <span class="hljs-built_in">add</span> 192.168.200.1/24 dev docker0
sudo<span class="hljs-built_in"> ip </span>link <span class="hljs-built_in">set</span> dev docker0 up</code></pre></div>
<p>第三步 配置Docker的文件：<br />
注意： 这里是 增加下面的配置</p>
<div><pre class="hljs"><code>vi /etc/docker/daemon.json
{
<span class="hljs-meta">...</span> <span class="language-javascript"><span class="hljs-string">"bip"</span>: <span class="hljs-string">"192.168.200.1/24"</span>,</span>
<span class="hljs-meta">...</span>
}</code></pre></div>
<p>第四步 重启主机：</p>
<div><pre class="hljs"><code><span class="hljs-attribute">sudo reboot</span></code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Linux进程内存使用查询方法]]></title>
            <guid>6436f738f30c41649cbaf2ababad4e5f</guid>
            <pubDate>Wed, 17 Jan 2024 02:53:42 GMT</pubDate>
            <content:encoded><![CDATA[<p>linux查看进程占用内存情况<br />
在Linux系统中，我们经常需要查看进程占用内存的情况，以便及时发现和解决内存相关的问题。下面将介绍几种常用的方法来查看进程占用内存的情况。</p>
<ol>
<li>使用top命令</li>
</ol>
<p>top命令是一个非常强大的系统监视工具，可以实时查看系统的资源使用情况。通过top命令，我们可以查看进程的CPU占用率、内存占用率等信息。</p>
<p>要使用top命令查看进程占用内存情况，可以按下Shift+M键，按照内存占用率进行排序。这样就可以看到占用内存最多的进程。</p>
<ol start="2">
<li>使用ps命令</li>
</ol>
<p>ps命令可以用来查看系统中的进程信息。要查看进程的内存占用情况，可以使用ps命令的aux选项，然后按照内存占用量进行排序。</p>
<p>命令示例：ps aux --sort -rss</p>
<p>其中，-rss表示按照进程占用的物理内存大小进行排序。这样就可以看到占用内存最多的进程。</p>
<ol start="3">
<li>使用pmap命令</li>
</ol>
<p>pmap命令可以显示进程的内存映射情况，包括内存地址、权限、映射文件等信息。通过查看进程的内存映射情况，可以了解进程占用内存的详细情况。</p>
<p>命令示例：pmap -x &lt;进程ID&gt;</p>
<p>其中，&lt;进程ID&gt;是要查看的进程的ID。执行该命令后，会显示该进程占用的内存映射情况。</p>
<ol start="4">
<li>使用smem命令</li>
</ol>
<p>smem命令可以提供更详细的进程内存使用信息，包括物理内存、共享内存、内核内存等。通过smem命令，可以更全面地了解进程的内存占用情况。</p>
<p>命令示例：smem -r</p>
<p>执行该命令后，会显示系统中所有进程的内存使用情况，按照内存占用量进行排序。</p>
<p>通过以上几种方法，我们可以方便地查看Linux系统中进程的内存占用情况。根据实际需求，选择合适的方法来监视和优化系统的内存使用，以提高系统的性能和稳定性。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Centos查找软件包]]></title>
            <guid>256f0f4569d8420a9121bbecee00c9c0</guid>
            <pubDate>Mon, 15 Jan 2024 09:55:08 GMT</pubDate>
            <content:encoded><![CDATA[一、rpm -qR  httpd<br />
查询httpd依赖的软件包<br />
二、查找某个命令属于哪个rpm包<br />
1.1、使用rpm命令<br />
首先需要找到某个命令的位置，比如说这里的sar命令是在/usr/bin/sar这个位置然后用rpm这个命令查找sar命令属于sysstat包。<br />
#which sar<br />
输出/usr/bin/sar<br />
#rpm -qf /usr/bin/sar<br />
查询命令依赖包<br />
2.使用yum<br />
#yum  provides sar<br />
三、查看某个包的相关信息<br />
rpm -qi XXXX.el.x86_64<br />
四、查看某个包的所有的安装文件<br />
rpm -ql sysstat-12.5.4-3.el9.x86_64]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[docker自定义数据目录]]></title>
            <guid>28f5b3ebb82342c29733ecd536fe3344</guid>
            <pubDate>Mon, 15 Jan 2024 08:29:26 GMT</pubDate>
            <content:encoded><![CDATA[<p>1.systemctl stop docker<br />
2.mv /var/lib/docker /var/lib/docker.bak<br />
3.mkdir /data/docker<br />
4.vim /etc/docker/daemon.json<br />
{</p>
<p>"data-root": "/data/docker"<br />
}<br />
5.systemctl start docker<br />
6.docker info|grep 'Docker Root Dir'</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[docker配置日志]]></title>
            <guid>5c6966d71cfd4b058dd1b15cb88818a6</guid>
            <pubDate>Mon, 15 Jan 2024 08:28:10 GMT</pubDate>
            <content:encoded><![CDATA[/etc/docker/daemon.json<br />
{<br />
"log-driver": "json-file",<br />
"log-opts": {<br />
"max-size": "10m",<br />
"max-file": "3"<br />
}<br />
}]]></content:encoded>
        </item>
    </channel>
</rss>