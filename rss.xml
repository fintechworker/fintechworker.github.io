<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Tue, 20 Feb 2024 03:13:46 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[Dockerfile指令详解]]></title>
            <guid>f9a74c05fb8849a5b41bb73e21abbb6a</guid>
            <pubDate>Mon, 05 Feb 2024 08:47:45 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="1copy-复制文件">1.COPY 复制文件</h1>
<p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code><br />
和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。<br />
<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：<br />
<code>COPY package.json /usr/src/app/`` </code>&lt;源路径&gt;<code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [</code>filepath.Match`]规则，如：</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。<br />
在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">55</span>:mygroup files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=bin files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">1</span> files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">10</span>:<span class="hljs-number">11</span> files* <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h1 id="2add-更高级的复制文件">2.ADD 更高级的复制文件</h1>
<p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。<br />
比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。<br />
如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。<br />
在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> scratch
<span class="hljs-built_in">ADD</span> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /
<span class="hljs-built_in">..</span>.</code></pre></div>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。<br />
在 Docker 官方的 <a title="https://yeasy.gitbook.io/docker_practice/appendix/best_practices" href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=55:mygroup files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=bin files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=1 files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=10:11 files* /mydir/</code></pre></div>
<h1 id="3cmd-容器启动命令">3.CMD 容器启动命令</h1>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></li>
<li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<p><code>CMD echo $HOME</code></p>
<p>在实际执行中，会将其变更为：</p>
<p><code>CMD [ "sh", "-c", "echo $HOME" ]</code></p>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。<br />
Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<p>CMD service nginx start</p>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 init 系统以后台守护进程的形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<p><code>CMD ["nginx", "-g", "daemon off;"]</code></p>
<h1 id="4entrypoint-入口点">4.ENTRYPOINT 入口点</h1>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。<br />
<code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。<br />
当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：<br />
<code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code><br />
那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处么？让我们来看几个场景。</p>
<h3 id="场景一让镜像变成像命令一样使用">场景一：让镜像变成像命令一样使用</h3>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
CMD [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：<br />
<code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> myip -i
docker: <span class="hljs-built_in">Error</span> response <span class="hljs-keyword">from</span> daemon: invalid header field value <span class="hljs-string">"oci runtime error: container_linux.go:247: starting container process caused \\"</span>exec: \\\\\<span class="hljs-string">"-i\\\\\": executable file not found in <span class="hljs-variable">$PATH</span>\\"</span>\\n<span class="hljs-string">".</span></code></pre></div>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<p>`$ docker run myip curl  -s <a title="http://myip.ipip.net" href="http://myip.ipip.net">http://myip.ipip.net</a> -i</p>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
ENTRYPOINT [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<p><code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<div><pre class="hljs"><code>$ docker run myip -i
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-keyword">Server</span>: nginx/<span class="hljs-number">1.8</span><span class="hljs-number">.0</span>
<span class="hljs-type">Date</span>: Tue, <span class="hljs-number">22</span> Nov <span class="hljs-number">2016</span> <span class="hljs-number">05</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40</span> GMT
Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; 
 charset=UTF<span class="hljs-number">-8</span>
Vary: Accept-<span class="hljs-keyword">Encoding</span>
X-Powered-<span class="hljs-keyword">By</span>: PHP/<span class="hljs-number">5.6</span><span class="hljs-number">.24</span><span class="hljs-number">-1</span>~dotdeb+<span class="hljs-number">7.1</span>
X-<span class="hljs-keyword">Cache</span>: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>
X-<span class="hljs-keyword">Cache</span>-Lookup: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>
X-<span class="hljs-keyword">Cache</span>: MISS from proxy<span class="hljs-number">-2</span>_6
Transfer-<span class="hljs-keyword">Encoding</span>: chunked
Via: <span class="hljs-number">1.1</span> <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>, <span class="hljs-number">1.1</span> proxy<span class="hljs-number">-2</span>_6:<span class="hljs-number">8006</span>
<span class="hljs-keyword">Connection</span>: keep-alive</code></pre></div>
<p>当前 IP：61.148.226.66 来自：北京市 联通<br />
可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h3 id="场景二应用运行前的准备工作">场景二：应用运行前的准备工作</h3>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。<br />
比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。<br />
此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。<br />
这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.4</span>
...
<span class="hljs-keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span>
...
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"docker-entrypoint.sh"</span>]</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6379</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"redis-server"</span> ]</span></code></pre></div>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/sh</span>
...
<span class="hljs-comment"># allow the container to be started with `--user`</span>
<span class="hljs-keyword">if</span> [  <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>  =  <span class="hljs-string">'redis-server'</span>  -a  <span class="hljs-string">"<span class="hljs-subst">$(id  -u)</span>"</span>  =  <span class="hljs-string">'0'</span> ]; <span class="hljs-keyword">then</span>
    find . \!  -user redis -<span class="hljs-built_in">exec</span>  chown redis <span class="hljs-string">'{}'</span> +<span class="hljs-built_in">exec</span> gosu redis <span class="hljs-string">"<span class="hljs-variable">$0</span>"</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">exec</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span></code></pre></div>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> -it redis id
<span class="hljs-attribute">uid</span>=0(root)  <span class="hljs-attribute">gid</span>=0(root)  <span class="hljs-attribute">groups</span>=0(root)</code></pre></div>
<h1 id="5env-设置环境变量">5.ENV 设置环境变量</h1>
<p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<div><pre class="hljs"><code>ENV <span class="hljs-attribute">VERSION</span>=1.0 <span class="hljs-attribute">DEBUG</span>=on \
        <span class="hljs-attribute">NAME</span>=<span class="hljs-string">"Happy Feet"</span></code></pre></div>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。<br />
定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<div><pre class="hljs"><code>ENV NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span>
RUN curl -SLO https://nodejs.org/dist/v$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION</span>/<span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION-linux-x64</span>.tar.xz<span class="hljs-string">"  \
  	  &amp;&amp; curl -SLO "</span>https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc<span class="hljs-string">" \
    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
    &amp;&amp; grep "</span> <span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz\\$<span class="hljs-string">" SHASUMS256.txt | sha256sum -c - \
    &amp;&amp; tar -xJf "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" -C /usr/local --strip-components=1 \
    &amp;&amp; rm "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" SHASUMS256.txt.asc SHASUMS256.txt \
    &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span></code></pre></div>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。<br />
可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h1 id="6arg-构建参数">6.ARG 构建参数</h1>
<p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p>
<p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<div><pre class="hljs"><code>ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p>
<div><pre class="hljs"><code><span class="hljs-comment"># 只在 FROM 中生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 要想在 FROM 之后使用，必须再次指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
对于多阶段构建，尤其要注意这个问题

<span class="hljs-comment"># 这个变量在每个 FROM 中都生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 1
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 2
对于上述 Dockerfile 两个 <span class="hljs-keyword">FROM</span> 指令都可以使用<span class="hljs-variable">${DOCKER_USERNAME}</span>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<h1 id="7volume-定义匿名卷">7.VOLUME 定义匿名卷</h1>
<p>格式为：</p>
<ul>
<li><code>VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。<br />
<code>VOLUME /data</code></p>
<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p>
<div><pre class="hljs"><code>$ docker run -d  -v mydata:/<span class="hljs-class"><span class="hljs-keyword">data</span> xxxx</span></code></pre></div>
<h1 id="8expose-暴露端口">8.EXPOSE 暴露端口</h1>
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h1 id="9workdir-指定工作目录">9.WORKDIR 指定工作目录</h1>
<p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span></code></pre></div>
<p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p>
<h1 id="10user-指定当前用户">10.USER 指定当前用户</h1>
<p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">RUN</span> groupadd -r redis &amp;&amp; useradd -r -g redis redis<span class="hljs-built_in">
USER </span>redis
<span class="hljs-built_in">RUN</span> [ <span class="hljs-string">"redis-server"</span> ]</code></pre></div>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a title="https://github.com/tianon/gosu" href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<div><pre class="hljs"><code><span class="hljs-comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span>
RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
<span class="hljs-comment"># 下载 gosu</span>
RUN wget -O <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu <span class="hljs-string">"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64"</span>  \
    &amp;&amp; chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu \
    &amp;&amp; gosu nobody true
<span class="hljs-comment"># 设置 CMD，并以另外的用户执行</span>
CMD \[ <span class="hljs-string">"exec"</span>, <span class="hljs-string">"gosu"</span>, <span class="hljs-string">"redis"</span>, <span class="hljs-string">"redis-server"</span> \]</code></pre></div>
<h1 id="11healthcheck-健康检查">11.HEALTHCHECK 健康检查</h1>
<p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li>
<p><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</p>
</li>
<li>
<p><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p>
</li>
<li>
<p><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</p>
</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<div><pre class="hljs"><code>FROM nginx

RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
HEALTHCHECK  --interval=<span class="hljs-number">5</span>s  --timeout=<span class="hljs-number">3</span>s  \
    CMD curl -fs http:<span class="hljs-regexp">//</span>localhost/ || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span></code></pre></div>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker build</code> 来构建这个镜像：</p>
<p><code>$ docker build -t myweb:v1 .</code></p>
<p>构建好了后，我们启动一个容器：<br />
``$ docker run -d  --name web -p  80:80 myweb:v1`</p>
<p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<div><pre class="hljs"><code><span class="language-xml">$ docker inspect --format  '</span><span class="hljs-template-variable">{{<span class="hljs-name">json</span> .State.Health}}</span><span class="language-xml">' web | python -m json.tool</span></code></pre></div>
<h1 id="12onbuild-为他人作嫁衣裳">12.ONBUILD 为他人作嫁衣裳</h1>
<p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br />
<code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。<br />
假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p>
<div><pre class="hljs"><code>FROM node:slim
<span class="hljs-keyword">RUN</span> <span class="hljs-keyword">mkdir</span> /<span class="hljs-keyword">app</span>
WORKDIR /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">COPY</span> ./package.json /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">RUN</span> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . /<span class="hljs-keyword">app</span>/
CMD [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</code></pre></div>
<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。<br />
如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。<br />
那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> my-node
<span class="hljs-keyword">COPY</span> .<span class="hljs-regexp">/package.json /</span>app
RUN [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . <span class="hljs-regexp">/app/</span></code></pre></div>
<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。<br />
那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。<br />
<code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">ONBUILD</span> 
<span class="hljs-keyword">COPY</span><span class="language-bash"> ./package.json /app</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">RUN</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">COPY</span><span class="language-bash"> . /app/</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<div><pre class="hljs"><code>FROM my-<span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h1 id="13label-为镜像添加元数据">13.LABEL 为镜像添加元数据</h1>
<p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。<br />
LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br />
我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<div><pre class="hljs"><code>LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.authors=<span class="hljs-string">"yeasy"</span>
LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.documentation=<span class="hljs-string">"https://yeasy.gitbooks.io"</span></code></pre></div>
<p>具体可以参考 <a title="https://github.com/opencontainers/image-spec/blob/master/annotations.md" href="https://github.com/opencontainers/image-spec/blob/master/annotations.md">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p>
<h1 id="14shell-指令">14.SHELL 指令</h1>
<p>格式：<code>SHELL ["executable", "parameters"]</code><br />
<code>SHELL</code> 指令可以指定 <code>RUN</code><br />
<code>ENTRYPOINT</code><br />
<code>CMD</code> 指令的 shell，Linux 中默认为 <code>["/bin/sh", "-c"]</code></p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span>
<span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span></code></pre></div>
<p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p>
<p>当 <code>ENTRYPOINT</code></p>
<p><code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span>
<span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> nginx</span></code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[dockerfile 哪些命令会构建新的镜像层]]></title>
            <guid>ffdd163ce89e449f891380e816e1b54f</guid>
            <pubDate>Mon, 05 Feb 2024 08:44:53 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="dockerfile-哪些命令会构建新的镜像层"><a id="Dockerfile__0" class="jop-noMdConv"></a>Dockerfile: 哪些命令会构建新的镜像层</h2>
<h3 id="导语"><a id="_2" class="jop-noMdConv"></a>导语</h3>
<p>在使用 Docker 进行容器化应用部署时，Dockerfile 是非常重要的一环。Dockerfile 是一个用于构建 Docker 镜像的文件，通过在 Dockerfile 中定义一系列的命令，我们可以自动化地构建、配置和部署容器化应用。在 Dockerfile 中，有一些特定的命令会导致 Docker 构建新的镜像层。本文将介绍这些命令，并提供相应的代码示例。</p>
<h3 id="1-dockerfile-简介"><a id="1_Dockerfile__6" class="jop-noMdConv"></a>1. Dockerfile 简介</h3>
<p>Dockerfile 是一个文本文件，其中包含了一系列用于构建 Docker 镜像的命令。通过 Dockerfile，我们可以定义从基础镜像到最终镜像的构建过程，并指定容器运行时的配置。使用 Dockerfile 可以实现自动化、可重复的镜像构建流程。</p>
<h3 id="2-dockerfile-构建新的镜像层的命令"><a id="2_Dockerfile__10" class="jop-noMdConv"></a>2. Dockerfile 构建新的镜像层的命令</h3>
<h4 id="21-from"><a id="21_FROM_12" class="jop-noMdConv"></a>2.1 FROM</h4>
<p><code>FROM</code> 命令用于指定基础镜像。在 Dockerfile 中，通常以 <code>FROM</code> 开头。当 Docker 构建镜像时，会从 Docker Hub 或本地镜像仓库拉取指定的基础镜像，并在其基础上构建新的镜像层。</p>
<p>以下是一个使用 <code>FROM</code> 命令的示例：</p>
<p>上述示例中，我们指定了基础镜像为最新版本的 Ubuntu。</p>
<h4 id="22-run"><a id="22_RUN_24" class="jop-noMdConv"></a>2.2 RUN</h4>
<p><code>RUN</code> 命令用于在容器中执行一条或多条命令，并将结果保存为新的镜像层。可以在 <code>RUN</code> 命令中执行任何可以在容器内部执行的命令，例如安装软件包、运行脚本等。每个 <code>RUN</code> 命令都会在当前镜像层的基础上生成一个新的镜像层。</p>
<p>以下是一个使用 <code>RUN</code> 命令的示例：</p>
<p>上述示例中，我们使用 <code>RUN</code> 命令更新了软件包列表，并安装了 Nginx。</p>
<h4 id="23-copy"><a id="23_COPY_36" class="jop-noMdConv"></a>2.3 COPY</h4>
<p><code>COPY</code> 命令用于将文件或目录从构建上下文复制到镜像中。每个 <code>COPY</code> 命令都会在当前镜像层的基础上生成一个新的镜像层。</p>
<p>以下是一个使用 <code>COPY</code> 命令的示例：</p>
<p>上述示例中，我们将 <code>app.jar</code> 文件复制到镜像的 <code>/app/</code> 目录下。</p>
<h4 id="24-add"><a id="24_ADD_48" class="jop-noMdConv"></a>2.4 ADD</h4>
<p><code>ADD</code> 命令功能类似于 <code>COPY</code> 命令，但是在复制文件或目录的同时，还支持自动解压缩和远程文件下载。每个 <code>ADD</code> 命令也会在当前镜像层的基础上生成一个新的镜像层。</p>
<p>以下是一个使用 <code>ADD</code> 命令的示例：</p>
<p>上述示例中，我们将远程的 <code>file.tar.gz</code> 文件下载并解压缩到镜像的 <code>/data/</code> 目录下。</p>
<h4 id="25-cmd"><a id="25_CMD_60" class="jop-noMdConv"></a>2.5 CMD</h4>
<p><code>CMD</code> 命令用于指定容器启动时要执行的命令。每个 Dockerfile 只能有一个 <code>CMD</code> 命令，如果有多个 <code>CMD</code> 命令，则只有最后一个有效。<code>CMD</code> 命令在创建容器时被指定为容器的默认命令，可以在运行容器时覆盖。</p>
<p>以下是一个使用 <code>CMD</code> 命令的示例：</p>
<p>上述示例中，我们指定了容器启动时要执行的命令为 <code>java -jar app.jar</code>。</p>
<h4 id="26-entrypoint">2.6 ENTRYPOINT</h4>
<p><code>ENTRYPOINT</code> 命令也用于指定容器启动时要执行的命令。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Dockerfile 定制镜像]]></title>
            <guid>85438dc178f744db80cf03f114b9bc0d</guid>
            <pubDate>Mon, 05 Feb 2024 08:12:36 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="1from-指定基础镜像">1.FROM 指定基础镜像</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> nginx
RUN echo <span class="hljs-string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html</code></pre></div>
<p>Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<div><pre class="hljs"><code>FROM scratch
<span class="hljs-meta">...</span></code></pre></div>
<h3 id="2run-执行命令">2.RUN 执行命令</h3>
<p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</li>
</ul>
<div><pre class="hljs"><code>RUN echo <span class="hljs-string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html</code></pre></div>
<ul>
<li>exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。</li>
</ul>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。<br />
上面的 Dockerfile 正确的写法应该是这样：</p>
<div><pre class="hljs"><code>FROM debian:stretch

RUN set -x; buildDeps=<span class="hljs-string">'gcc libc6-dev make wget'</span> \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \
    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \
    &amp;&amp; mkdir -p <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C <span class="hljs-regexp">/usr/</span>src/redis --strip-components=<span class="hljs-number">1</span> \
    &amp;&amp; make -C <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; make -C <span class="hljs-regexp">/usr/</span>src/redis install \
    &amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></code></pre></div>
<p>Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。<br />
此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h3 id="3构建镜像">3.构建镜像</h3>
<p>docker build [选项] &lt;上下文路径/URL/-&gt;<br />
<code>docker build -t nginx:v3 .</code></p>
<h3 id="4镜像构建上下文context">4.镜像构建上下文（Context）</h3>
<p>如果注意，会看到 docker build 命令最后有一个<code> .</code>。<code>.</code> 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？<br />
首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<br />
当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？<br />
这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。<br />
如果在 Dockerfile 中这么写：<br />
<code>COPY ./package.json /app/</code><br />
这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。<br />
因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。<br />
现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。<br />
如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">build </span>-t nginx:v3 .
Sending <span class="hljs-keyword">build </span><span class="hljs-built_in">context</span> to Docker daemon <span class="hljs-number">2</span>.<span class="hljs-number">048</span> kB
...</code></pre></div>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。<br />
一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。<br />
那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。<br />
这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用<code> -f ../Dockerfile.php</code> 参数指定某个文件作为 Dockerfile。<br />
当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[00013.shell参数]]></title>
            <guid>753404f27aeb4a839a3ba79874d9ae28</guid>
            <pubDate>Tue, 23 Jan 2024 01:51:26 GMT</pubDate>
            <content:encoded><![CDATA[<p>一、参数个数标识<br />
path/to/scriptname opt1 opt2 opt3 opt4<br />
$0 $1 $2 $3 <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">4</span></span></span></span></span># ：代表后接的参数『个数』，以上表为例这里显示为『 4 』；<br />
$@ ：代表『 "$1" "$2" "$3" "<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi mathvariant="normal">"</mi><mtext>』之意，每个变量是独立的</mtext><mo stretchy="false">(</mo><mtext>用双引号括起来</mtext><mo stretchy="false">)</mo><mtext>；</mtext></mrow><annotation encoding="application/x-tex">4" 』之意，每个变量是独立的(用双引号括起来)；
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">4"</span><span class="mord cjk_fallback">』之意，每个变量是独立的</span><span class="mopen">(</span><span class="mord cjk_fallback">用双引号括起来</span><span class="mclose">)</span><span class="mord cjk_fallback">；</span></span></span></span></span>* ：代表『 "$1c$2c$3c$4" 』，其中 c 为分割字符，默认为空格键， 所以本例中代表『 "$1 $2 $3 $4" 』之意</p>
<p>二、shift<br />
示例1：依次读取输入的参数并打印参数个数：<br />
<img src="/_resources/56c30f2c12ec49c39035c28af8674f1c.png" /><br />
<img src="/_resources/ded447124a654afcab21e8118e82584b.png" /></p>
<p>从上可知 shift(shift 1) 命令每执行一次，变量的个数($#)减一（之前的$1变量被销毁,之后的$2就变成了$1），而变量值提前一位。</p>
<p>同理，shift n后，前n位参数都会被销毁，例如示例2</p>
<p>示例2<br />
<img src="/_resources/d9203a2a3afd4c7cadad128ea158c2bb.png" /><br />
<img src="/_resources/49f4fa1f33d94d3c93a328ee03512267.png" /><br />
运行结果：</p>
<p>示例3：</p>
<p>命令行参数处理<br />
./imx6mksdboot.sh -device /dev/sdd -flash emmc -ddrsize 512</p>
<p>#命令行处理，根据选项获得参数</p>
<div><pre class="hljs"><code><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$#</span> -gt 0 ]; <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>
    --<span class="hljs-built_in">help</span> | -h)
      usage <span class="hljs-variable">$0</span>
      ;;
    -device) <span class="hljs-built_in">shift</span>; device=<span class="hljs-variable">$1</span>; <span class="hljs-built_in">shift</span>; ;;               
    -flash) <span class="hljs-built_in">shift</span>; flash=<span class="hljs-variable">$1</span>; <span class="hljs-built_in">shift</span>; ;;
    -ddrsize) <span class="hljs-built_in">shift</span>; ddrsize=<span class="hljs-variable">$1</span>; <span class="hljs-built_in">shift</span>; ;;
    --version) version <span class="hljs-variable">$0</span>;;
    *) copy=<span class="hljs-string">"<span class="hljs-variable">$copy</span> <span class="hljs-variable">$1</span>"</span>; <span class="hljs-built_in">shift</span>; ;;
  <span class="hljs-keyword">esac</span>
<span class="hljs-keyword">done</span></code></pre></div>
<p>当命令中有 -device时，会使用shift将参数左移，也就是去掉此前的$1，也就是命令中-device，此时的$1就成为了后面的 /dev/sdd，这样就让device变量等于/dev/sdd，一次类推</p>
<p>usage $0是函数调用，将$0也就是脚本的名字掺入usage 函数中，在函数中需要用$1来获取</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[00004.lsof用法]]></title>
            <guid>a708c849e49b48f9b310a9e094198b65</guid>
            <pubDate>Thu, 18 Jan 2024 00:55:35 GMT</pubDate>
            <content:encoded><![CDATA[<p>lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，用户通过文件不仅可以访问常规数据，还可以访问网络连接和硬件；如传输控制协议 (TCP) 和用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于此应用程序的信息。本期，ISEC实验室的刘老师为大家详解lsof的用法。</p>
<p>一、命令参数</p>
<p>-a：列出打开文件存在的进程；</p>
<p>-c&lt;进程名&gt;：列出指定进程所打开的文件；</p>
<p>-g：列出GID号进程详情；</p>
<p>-d&lt;文件号&gt;：列出占用该文件号的进程；</p>
<p>+d&lt;目录&gt;：列出目录下被打开的文件；</p>
<p>+D&lt;目录&gt;：递归列出目录下被打开的文件；</p>
<p>-n&lt;目录&gt;：列出使用NFS的文件；</p>
<p>-i&lt;条件&gt;：列出符合条件的进程(4、6、协议、:端口、 @ip )；</p>
<p>-p&lt;进程号&gt;：列出指定进程号所打开的文件；</p>
<p>-u：列出UID号进程详情；</p>
<p>-h：显示帮助信息；</p>
<p>-v：显示版本信息。</p>
<p>二、实例讲解</p>
<p><img src="/_resources/75610d82c3d44613849c5f7d741c24ae.png" /></p>
<p>1、lsof输出各列信息的意义，如下：</p>
<p>COMMAND：进程的名称；</p>
<p>PID：进程标识符；</p>
<p>PPID：父进程标识符(需要指定-R参数)；</p>
<p>USER：进程所有者；</p>
<p>PGID：进程所属组；</p>
<p>FD：文件描述符，应用程序通过文件描述符识别该文件。</p>
<p>2、文件描述符列表：</p>
<p>①. cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改；</p>
<p>②. txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序；</p>
<p>③. lnn：library references (AIX)；</p>
<p>④. er：FD information error (see NAME column)；</p>
<p>⑤. jld：jail directory (FreeBSD)；</p>
<p>⑥. ltx：shared library text (code and data)；</p>
<p>⑦. mxx ：hex memory-mapped type number xx.</p>
<p>⑧. m86：DOS Merge mapped file；</p>
<p>⑨. mem：memory-mapped file；</p>
<p>⑩. mmap：memory-mapped device；</p>
<p>. pd：parent directory；</p>
<p>. rtd：root directory；</p>
<p>. tr：kernel trace file (OpenBSD)；</p>
<p>. v86 VP/ix mapped file；</p>
<p>. 0：表示标准输出；</p>
<p>. 1：表示标准输入；</p>
<p>. 2：表示标准错误。</p>
<p>3、一般在标准输出、标准错误、标准输入后，还跟着文件状态模式：</p>
<p>①.u：表示该文件被打开并处于读取/写入模式；</p>
<p>②.r：表示该文件被打开并处于只读模式；</p>
<p>③.w：表示该文件被打开并处于只写模式；</p>
<p>④.空格：表示该文件的状态模式为unknow，且没有锁定；</p>
<p>⑤.-：表示该文件的状态模式为unknow，且被锁定。</p>
<p>4、同时在文件状态模式后面，还跟着相关的锁：</p>
<p>①. N：for a Solaris NFS lock of unknown type；</p>
<p>②. r：for read lock on part of the file；</p>
<p>③. R：for a read lock on the entire file；</p>
<p>④. w：for a write lock on part of the file；(文件的部分写锁)</p>
<p>⑤. W：for a write lock on the entire file；(整个文件的写锁)</p>
<p>⑥. u：for a read and write lock of any length；</p>
<p>⑦. U：for a lock of unknown type；</p>
<p>⑧. x：for an SCO OpenServer Xenix lock on part of the file；</p>
<p>⑨. X：for an SCO OpenServer Xenix lock on the entire file；</p>
<p>⑩. space：if there is no lock。</p>
<p>5、文件类型</p>
<p>①. DIR：表示目录；</p>
<p>②. CHR：表示字符类型；</p>
<p>③. BLK：块设备类型；</p>
<p>④. UNIX：UNIX 域套接字；</p>
<p>⑤. FIFO：先进先出 (FIFO) 队列；</p>
<p>⑥. IPv4：网际协议 (IP) 套接字；</p>
<p>⑦. DEVICE：指定磁盘的名称；</p>
<p>⑧. SIZE：文件的大小；</p>
<p>⑨. NODE：索引节点(文件在磁盘上的标识)；</p>
<p>⑩. NAME：打开文件的确切名称。</p>
<p>三、可打开文件</p>
<p>①. 普通文件；</p>
<p>②. 目录；</p>
<p>③. 网络文件系统的文件；</p>
<p>④. 字符或设备文件；</p>
<p>⑤. (函数)共享库；</p>
<p>⑥. 管道，命名管道；</p>
<p>⑦. 符号链接；</p>
<p>⑧. 网络文件(例如：NFS file、网络socket，unix域名socket)；</p>
<p>⑨. 其它类型的文件等。</p>
<p>四、常规用法</p>
<p>lsof 常被用来查找应用程序打开的文件名称和数目，系统管理员可能想尝试找出某个特定应用程序将日志数据记录到何处，或者正在跟踪某个问题。接下来，我们来看看是如何操作的：</p>
<p>1、进程篇</p>
<p>(1)、查看由登陆用户启动而非系统启动的进程：</p>
<p>命令： lsof /dev/pts0<br />
<img src="/_resources/2d4b712ed5fd4fdfbebc428d23460617.png" /></p>
<p>a. /dev/pts是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录；</p>
<p>b. 第一个用户登陆，console的设备文件为/dev/pts/0，第二个为/dev/pts/1，以此类推；</p>
<p>c. 通过查看/dev/pts下的进程，我们将可以了解到由登陆用户启动而非系统启动的进程有哪些。</p>
<p>(2)、查看文件，设备被哪些进程占用：</p>
<p>命令：lsof /dev/tty1</p>
<p><img src="/_resources/82de2d48d0f5415687cb2f321bafe71a.png" /></p>
<p>a. /dev/tty就是当前进程的控制终端的设备特殊文件；</p>
<p>b. 通过查看/dev/tty下文件可以知道文件、设备的进程占用情况。</p>
<p>(3)、指定进程号，可以查看该进程打开的文件：</p>
<p>命令：lsof -p 27358<br />
<img src="/_resources/a7d25645610741069caba7553c709fe2.png" /><br />
a. 通过加入参数-p，我们可以指定一个PID，然后查看该进程下打开的文件。</p>
<p>b. 本例我们查看的是nginx下打开的相关文件。</p>
<p>2、文件篇</p>
<p>(1)、查看指定程序打开的文件</p>
<p>命令：lsof -c sshd<br />
<img src="/_resources/fd4391ae7e584c098bc1deaa5236422e.png" /><br />
通过参数-c可以列出指定进程所打开的文件情况，以上是我们打开sshd下被打开文件的情况。</p>
<p>(2)、查看指定用户打开的文件</p>
<p>命令：lsof -u root | more</p>
<p><img src="/_resources/f7b13316c2a241d7a0038417dcf0c129.png" /></p>
<p>通过参数-u查看root用户下存在的文件情况，由于root下显示内容较多，可以利用more来限制，进行分页查看。</p>
<p>(3)、查看指定目录下被打开的文件</p>
<p>命令：lsof +D /home/ 或lsof +d /home/</p>
<p><img src="/_resources/8acadd009f97488684321d30eecb251c.png" /></p>
<p>参数+D为递归列出/home/下被打开的文件，参数+d为列出/home/下被打开的文件。</p>
<p>3、网络篇</p>
<p>(1)、查看所有网络连接</p>
<p>命令：lsof -i 和 lsof -i@127.0.0.1　　<br />
<img src="/_resources/3d8ee1ed8fad410ab36f76600d9f58de.png" /><br />
<img src="/_resources/e59736e9384f4b5d9102983235ca593b.png" /></p>
<p>通过参数-i查看网络连接的情况，包括连接的ip、端口等；以及一些服务的连接情况，例如：sshd等。也可以通过指定ip查看该ip的网络连接情况。</p>
<p>(2)、查看端口连接情况</p>
<p>命令：lsof -i :22<br />
<img src="/_resources/3bc95b57a05e4694b481513b8e7f1333.png" /></p>
<p>通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等。</p>
<p>4、综合篇</p>
<p>(1)、查看指定进程打开的网络连接</p>
<p>命令：lsof -i -a -p 1535</p>
<p><img src="/_resources/a287934cd706491284fefcac2f726b9a.png" /></p>
<p>使用了参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进程。</p>
<p>(2)、查看指定状态的网络连接</p>
<p>命令：lsof -n -P -i TCP -s TCP:ESTABLISHED</p>
<p><img src="/_resources/4a1d814e9a744a8eaa5332dc138ccb58.png" /></p>
<p>参数解释： -n:no host names, -P:no port names,-i TCP指定协议，-s指定协议状态；通过多个参数我们可以清晰的查看网络连接情况、协议连接情况等。</p>
<p>五、恢复被删除的日志</p>
<p>Linux的系统日志默认保存在/var/log下<br />
<img src="/_resources/b140ba0f5c8f447bb2857cb38b8c6506.png" /></p>
<p>当Linux系统被入侵后，很多入侵者经常会删除系统中的各种日志，包括Web的access和error日志、last日志、messages日志、secure日志等，阻碍应急响应和取证调查，比如rm -rf /var/log。</p>
<p><img src="/_resources/03d4adef27be4b3da9e56c6f6fb2a6b2.png" /></p>
<p>遇到这种情况，不要关闭或者重启服务器系统，也不要关闭或重启相关服务或者进程，如：恢复apache的访问日志/var/log/httpd/access_log时，不能关闭或者重启服务器系统，也不能重启httpd服务。</p>
<p>假设我们要恢复被删除的messages日志和secure日志：</p>
<p>1.首先通过losf命令找到使用messages文件的进程的PID和messages文件的FD(文件描述符)；<br />
<img src="/_resources/34f002b904f14f88a1e2578cf872da5b.png" /></p>
<p>从上面命令输出可以看到，这个打开/var/log/messages文件的进程的PID是815，文件/var/log/messages的FD(文件描述符)是4，状态为deleted，标记被删除，但其实该文件并没有从磁盘中删除。</p>
<p>2.如果删除的文件还存在操作的进程，数据将可能被找回，可以在/proc/815/fd/4找到被删除的/var/log/messages文件；</p>
<p><img src="/_resources/4527d233a84f4335a921a32883cea4ee.png" /></p>
<p><img src="/_resources/3c90506ddfc34a14b821daa48e2299c2.png" /></p>
<p>3.恢复被删除的/var/log/secure文件；</p>
<p><img src="/_resources/3ca870a5bc334972b09e2da7d27a5c89.png" /></p>
<p>在Linux系统中删除了一个文件，只要进程还在对文件进行操作，就可能还存在一个inode的引用：/proc/进程号/fd/文件描述符，只要知道当前打开文件的进程pid和文件描述符fd，即可利用lsof命令还原出被删除的文件。</p>
<p>六、总 结</p>
<p>Linux大量使用了文件，作为系统管理员，lsof 允许用户对核心内存进行查看，以找出系统当前如何使用这些文件。lsof的简单用法可以告诉用户哪些进程打开了哪些文件，以及哪些文件由哪些进程打开。</p>
<p>在收集关于应用程序工作情况的信息时，或在进行某些可能损坏数据的操作前，要确保文件未被使用，这一点特别重要。lsof 更高级的用法可以帮助用户查找删除的文件，并获得关于网络连接的信息。lsof 是一个功能强大的工具，它几乎可以用于任何地方。</p>
]]></content:encoded>
        </item>
    </channel>
</rss>