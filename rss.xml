<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Thu, 22 Feb 2024 16:38:44 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[测试0001]]></title>
            <guid>fba8fd6ebeeb4711b16495939736672e</guid>
            <pubDate>Thu, 22 Feb 2024 09:32:48 GMT</pubDate>
            <content:encoded><![CDATA[<p>测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001<br />
测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001</p>
<p>测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001测试0001<br />
测试0001测试0001</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[009.Dockerfile指令详解]]></title>
            <guid>f9a74c05fb8849a5b41bb73e21abbb6a</guid>
            <pubDate>Mon, 05 Feb 2024 08:47:45 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="1copy-复制文件">1.COPY 复制文件</h1>
<p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。<br />
<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：<br />
<code>COPY package.json /usr/src/app/`` </code>&lt;源路径&gt;<code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [</code>filepath.Match`]规则，如：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。<br />
在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">55</span>:mygroup files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=bin files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">1</span> files* <span class="hljs-regexp">/mydir/</span>
<span class="hljs-keyword">COPY</span>  --chown=<span class="hljs-number">10</span>:<span class="hljs-number">11</span> files* <span class="hljs-regexp">/mydir/</span></code></pre></div>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h1 id="2add-更高级的复制文件">2.ADD 更高级的复制文件</h1>
<p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。<br />
比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。<br />
如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。<br />
在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> scratch
<span class="hljs-built_in">ADD</span> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /
<span class="hljs-built_in">..</span>.</code></pre></div>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a title="https://yeasy.gitbook.io/docker_practice/appendix/best_practices" href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=55:mygroup files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=bin files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=1 files* /mydir/
<span class="hljs-built_in">ADD</span>  <span class="hljs-attribute">--chown</span>=10:11 files* /mydir/</code></pre></div>
<h1 id="3cmd-容器启动命令">3.CMD 容器启动命令</h1>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></li>
<li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<p><code>CMD echo $HOME</code></p>
<p>在实际执行中，会将其变更为：</p>
<p><code>CMD [ "sh", "-c", "echo $HOME" ]</code></p>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。<br />
Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<p>CMD service nginx start</p>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 init 系统以后台守护进程的形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<p><code>CMD ["nginx", "-g", "daemon off;"]</code></p>
<h1 id="4entrypoint-入口点">4.ENTRYPOINT 入口点</h1>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。<br />
<code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。<br />
当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：<br />
<code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code><br />
那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处么？让我们来看几个场景。</p>
<h3 id="场景一让镜像变成像命令一样使用">场景一：让镜像变成像命令一样使用</h3>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
CMD [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：<br />
<code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> myip -i
docker: <span class="hljs-built_in">Error</span> response <span class="hljs-keyword">from</span> daemon: invalid header field value <span class="hljs-string">"oci runtime error: container_linux.go:247: starting container process caused \\"</span>exec: \\\\\<span class="hljs-string">"-i\\\\\": executable file not found in <span class="hljs-variable">$PATH</span>\\"</span>\\n<span class="hljs-string">".</span></code></pre></div>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<p>`$ docker run myip curl  -s <a title="http://myip.ipip.net" href="http://myip.ipip.net">http://myip.ipip.net</a> -i</p>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<div><pre class="hljs"><code>FROM ubuntu:<span class="hljs-number">18.04</span>
RUN apt-get update \
&amp;&amp; apt-get install -y curl \
&amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
ENTRYPOINT [ <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"http://myip.ipip.net"</span> ]</code></pre></div>
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<p><code>$ docker run myip</code></p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<div><pre class="hljs"><code>$ docker run myip -i
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-keyword">Server</span>: nginx/<span class="hljs-number">1.8</span><span class="hljs-number">.0</span>
<span class="hljs-type">Date</span>: Tue, <span class="hljs-number">22</span> Nov <span class="hljs-number">2016</span> <span class="hljs-number">05</span>:<span class="hljs-number">12</span>:<span class="hljs-number">40</span> GMT
Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; 
 charset=UTF<span class="hljs-number">-8</span>
Vary: Accept-<span class="hljs-keyword">Encoding</span>
X-Powered-<span class="hljs-keyword">By</span>: PHP/<span class="hljs-number">5.6</span><span class="hljs-number">.24</span><span class="hljs-number">-1</span>~dotdeb+<span class="hljs-number">7.1</span>
X-<span class="hljs-keyword">Cache</span>: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>
X-<span class="hljs-keyword">Cache</span>-Lookup: MISS from <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>
X-<span class="hljs-keyword">Cache</span>: MISS from proxy<span class="hljs-number">-2</span>_6
Transfer-<span class="hljs-keyword">Encoding</span>: chunked
Via: <span class="hljs-number">1.1</span> <span class="hljs-keyword">cache</span><span class="hljs-number">-2</span>:<span class="hljs-number">80</span>, <span class="hljs-number">1.1</span> proxy<span class="hljs-number">-2</span>_6:<span class="hljs-number">8006</span>
<span class="hljs-keyword">Connection</span>: keep-alive</code></pre></div>
<p>当前 IP：61.148.226.66 来自：北京市 联通<br />
可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h3 id="场景二应用运行前的准备工作">场景二：应用运行前的准备工作</h3>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。<br />
比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。<br />
此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。<br />
这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.4</span>
...
<span class="hljs-keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span>
...
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">"docker-entrypoint.sh"</span>]</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6379</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"redis-server"</span> ]</span></code></pre></div>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<div><pre class="hljs"><code><span class="hljs-meta">#!/bin/sh</span>
...
<span class="hljs-comment"># allow the container to be started with `--user`</span>
<span class="hljs-keyword">if</span> [  <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>  =  <span class="hljs-string">'redis-server'</span>  -a  <span class="hljs-string">"<span class="hljs-subst">$(id  -u)</span>"</span>  =  <span class="hljs-string">'0'</span> ]; <span class="hljs-keyword">then</span>
    find . \!  -user redis -<span class="hljs-built_in">exec</span>  chown redis <span class="hljs-string">'{}'</span> +<span class="hljs-built_in">exec</span> gosu redis <span class="hljs-string">"<span class="hljs-variable">$0</span>"</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">exec</span>  <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span></code></pre></div>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-built_in">run</span> -it redis id
<span class="hljs-attribute">uid</span>=0(root)  <span class="hljs-attribute">gid</span>=0(root)  <span class="hljs-attribute">groups</span>=0(root)</code></pre></div>
<h1 id="5env-设置环境变量">5.ENV 设置环境变量</h1>
<p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<div><pre class="hljs"><code>ENV <span class="hljs-attribute">VERSION</span>=1.0 <span class="hljs-attribute">DEBUG</span>=on \
        <span class="hljs-attribute">NAME</span>=<span class="hljs-string">"Happy Feet"</span></code></pre></div>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。<br />
定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<div><pre class="hljs"><code>ENV NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span>
RUN curl -SLO https://nodejs.org/dist/v$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION</span>/<span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$<span class="hljs-keyword">NODE</span><span class="hljs-title">\_VERSION-linux-x64</span>.tar.xz<span class="hljs-string">"  \
  	  &amp;&amp; curl -SLO "</span>https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc<span class="hljs-string">" \
    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
    &amp;&amp; grep "</span> <span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz\\$<span class="hljs-string">" SHASUMS256.txt | sha256sum -c - \
    &amp;&amp; tar -xJf "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" -C /usr/local --strip-components=1 \
    &amp;&amp; rm "</span><span class="hljs-keyword">node</span><span class="hljs-title">-v</span>$NODE_VERSION-linux-x64.tar.xz<span class="hljs-string">" SHASUMS256.txt.asc SHASUMS256.txt \
    &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span></code></pre></div>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。<br />
可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h1 id="6arg-构建参数">6.ARG 构建参数</h1>
<p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p>
<p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<div><pre class="hljs"><code>ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p>
<div><pre class="hljs"><code><span class="hljs-comment"># 只在 FROM 中生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 要想在 FROM 之后使用，必须再次指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
对于多阶段构建，尤其要注意这个问题

<span class="hljs-comment"># 这个变量在每个 FROM 中都生效</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 1
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo 2
对于上述 Dockerfile 两个 <span class="hljs-keyword">FROM</span> 指令都可以使用<span class="hljs-variable">${DOCKER_USERNAME}</span>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span>
<span class="hljs-keyword">FROM</span>  <span class="hljs-variable">${DOCKER_USERNAME}</span>/alpine

<span class="hljs-comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span>
ARG <span class="hljs-attribute">DOCKER_USERNAME</span>=library
<span class="hljs-built_in">RUN</span> <span class="hljs-built_in">set</span> -x ; echo <span class="hljs-variable">${DOCKER_USERNAME}</span></code></pre></div>
<h1 id="7volume-定义匿名卷">7.VOLUME 定义匿名卷</h1>
<p>格式为：</p>
<ul>
<li><code>VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。<br />
<code>VOLUME /data</code></p>
<p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p>
<div><pre class="hljs"><code>$ docker run -d  -v mydata:/<span class="hljs-class"><span class="hljs-keyword">data</span> xxxx</span></code></pre></div>
<h1 id="8expose-暴露端口">8.EXPOSE 暴露端口</h1>
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h1 id="9workdir-指定工作目录">9.WORKDIR 指定工作目录</h1>
<p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> \&gt; world.txt</span></code></pre></div>
<p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span></code></pre></div>
<p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p>
<h1 id="10user-指定当前用户">10.USER 指定当前用户</h1>
<p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<div><pre class="hljs"><code><span class="hljs-built_in">RUN</span> groupadd -r redis &amp;&amp; useradd -r -g redis redis<span class="hljs-built_in">
USER </span>redis
<span class="hljs-built_in">RUN</span> [ <span class="hljs-string">"redis-server"</span> ]</code></pre></div>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a title="https://github.com/tianon/gosu" href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<div><pre class="hljs"><code><span class="hljs-comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span>
RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
<span class="hljs-comment"># 下载 gosu</span>
RUN wget -O <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu <span class="hljs-string">"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64"</span>  \
    &amp;&amp; chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/g</span>osu \
    &amp;&amp; gosu nobody true
<span class="hljs-comment"># 设置 CMD，并以另外的用户执行</span>
CMD \[ <span class="hljs-string">"exec"</span>, <span class="hljs-string">"gosu"</span>, <span class="hljs-string">"redis"</span>, <span class="hljs-string">"redis-server"</span> \]</code></pre></div>
<h1 id="11healthcheck-健康检查">11.HEALTHCHECK 健康检查</h1>
<p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li>
<p><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</p>
</li>
<li>
<p><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p>
</li>
<li>
<p><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</p>
</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<div><pre class="hljs"><code>FROM nginx

RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/*
HEALTHCHECK  --interval=<span class="hljs-number">5</span>s  --timeout=<span class="hljs-number">3</span>s  \
    CMD curl -fs http:<span class="hljs-regexp">//</span>localhost/ || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span></code></pre></div>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker build</code> 来构建这个镜像：</p>
<p><code>$ docker build -t myweb:v1 .</code></p>
<p>构建好了后，我们启动一个容器：<br />
``$ docker run -d  --name web -p  80:80 myweb:v1`</p>
<p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span></code></pre></div>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<div><pre class="hljs"><code><span class="language-xml">$ docker inspect --format  '</span><span class="hljs-template-variable">{{<span class="hljs-name">json</span> .State.Health}}</span><span class="language-xml">' web | python -m json.tool</span></code></pre></div>
<h1 id="12onbuild-为他人作嫁衣裳">12.ONBUILD 为他人作嫁衣裳</h1>
<p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br />
<code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。<br />
假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p>
<div><pre class="hljs"><code>FROM node:slim
<span class="hljs-keyword">RUN</span> <span class="hljs-keyword">mkdir</span> /<span class="hljs-keyword">app</span>
WORKDIR /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">COPY</span> ./package.json /<span class="hljs-keyword">app</span>
<span class="hljs-keyword">RUN</span> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . /<span class="hljs-keyword">app</span>/
CMD [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</code></pre></div>
<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。<br />
如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。<br />
那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> my-node
<span class="hljs-keyword">COPY</span> .<span class="hljs-regexp">/package.json /</span>app
RUN [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]
<span class="hljs-keyword">COPY</span> . <span class="hljs-regexp">/app/</span></code></pre></div>
<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。<br />
那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。<br />
<code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> node:slim
<span class="hljs-keyword">RUN</span><span class="language-bash"> mkdir /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>
<span class="hljs-keyword">ONBUILD</span> 
<span class="hljs-keyword">COPY</span><span class="language-bash"> ./package.json /app</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">RUN</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"install"</span> ]</span>
<span class="hljs-keyword">ONBUILD</span> 
 <span class="hljs-keyword">COPY</span><span class="language-bash"> . /app/</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span></code></pre></div>
<p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<div><pre class="hljs"><code>FROM my-<span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h1 id="13label-为镜像添加元数据">13.LABEL 为镜像添加元数据</h1>
<p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。<br />
LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br />
我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<div><pre class="hljs"><code>LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.authors=<span class="hljs-string">"yeasy"</span>
LABEL org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.documentation=<span class="hljs-string">"https://yeasy.gitbooks.io"</span></code></pre></div>
<p>具体可以参考 <a title="https://github.com/opencontainers/image-spec/blob/master/annotations.md" href="https://github.com/opencontainers/image-spec/blob/master/annotations.md">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p>
<h1 id="14shell-指令">14.SHELL 指令</h1>
<p>格式：<code>SHELL ["executable", "parameters"]</code><br />
<code>SHELL</code> 指令可以指定 <code>RUN</code><br />
<code>ENTRYPOINT</code><br />
<code>CMD</code> 指令的 shell，Linux 中默认为 <code>["/bin/sh", "-c"]</code></p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span>
<span class="hljs-keyword">SHELL </span>[<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]
RUN <span class="hljs-keyword">lll </span><span class="hljs-comment">; ls</span></code></pre></div>
<p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p>
<p>当 <code>ENTRYPOINT</code></p>
<p><code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p>
<div><pre class="hljs"><code><span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> nginx</span>
<span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-cex"</span>]</span>
<span class="hljs-comment"># /bin/sh -cex "nginx"</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> nginx</span></code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[007.使用 Dockerfile 定制镜像]]></title>
            <guid>85438dc178f744db80cf03f114b9bc0d</guid>
            <pubDate>Mon, 05 Feb 2024 08:12:36 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="1from-指定基础镜像">1.FROM 指定基础镜像</h3>
<div><pre class="hljs"><code><span class="hljs-keyword">FROM</span> nginx
RUN echo <span class="hljs-string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html</code></pre></div>
<p>Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<div><pre class="hljs"><code>FROM scratch
<span class="hljs-meta">...</span></code></pre></div>
<h3 id="2run-执行命令">2.RUN 执行命令</h3>
<p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</li>
</ul>
<div><pre class="hljs"><code>RUN echo <span class="hljs-string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html</code></pre></div>
<ul>
<li>exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。</li>
</ul>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。<br />
上面的 Dockerfile 正确的写法应该是这样：</p>
<div><pre class="hljs"><code>FROM debian:stretch

RUN set -x; buildDeps=<span class="hljs-string">'gcc libc6-dev make wget'</span> \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \
    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \
    &amp;&amp; mkdir -p <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C <span class="hljs-regexp">/usr/</span>src/redis --strip-components=<span class="hljs-number">1</span> \
    &amp;&amp; make -C <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; make -C <span class="hljs-regexp">/usr/</span>src/redis install \
    &amp;&amp; rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r <span class="hljs-regexp">/usr/</span>src/redis \
    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></code></pre></div>
<p>Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。<br />
此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h3 id="3构建镜像">3.构建镜像</h3>
<p>docker build [选项] &lt;上下文路径/URL/-&gt;<br />
<code>docker build -t nginx:v3 .</code></p>
<h3 id="4镜像构建上下文context">4.镜像构建上下文（Context）</h3>
<p>如果注意，会看到 docker build 命令最后有一个<code> .</code>。<code>.</code> 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？<br />
首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<br />
当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？<br />
这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。<br />
如果在 Dockerfile 中这么写：<br />
<code>COPY ./package.json /app/</code><br />
这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。<br />
因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。<br />
现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。<br />
如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p>
<div><pre class="hljs"><code>$ docker <span class="hljs-keyword">build </span>-t nginx:v3 .
Sending <span class="hljs-keyword">build </span><span class="hljs-built_in">context</span> to Docker daemon <span class="hljs-number">2</span>.<span class="hljs-number">048</span> kB
...</code></pre></div>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。<br />
一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。<br />
那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。<br />
这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用<code> -f ../Dockerfile.php</code> 参数指定某个文件作为 Dockerfile。<br />
当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[006.docker命令]]></title>
            <guid>77c28c4bfc5c4091a7f0aa3e30330811</guid>
            <pubDate>Mon, 05 Feb 2024 06:10:12 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="1获取镜像">1.获取镜像</h3>
<p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：<br />
<code>$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code><br />
具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。<br />
Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub(docker.io)。<br />
仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。<br />
比如：<br />
<code>$ docker pull ubuntu:18.04</code></p>
<h3 id="2运行镜像">2.运行镜像</h3>
<p><code>$ docker run -it --rm ubuntu:18.04 bash</code><br />
docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。<br />
-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br />
--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。<br />
ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。<br />
bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。<br />
进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。</p>
<h3 id="3列出镜像">3.列出镜像</h3>
<p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令</p>
<h3 id="4镜像体积">4.镜像体积</h3>
<p><code>$ docker system df</code></p>
<h3 id="5虚悬镜像">5.虚悬镜像</h3>
<p>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none class="jop-noMdConv"> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：<br />
<code>$ docker image ls -f dangling=true</code><br />
一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。<br />
<code>$ docker image prune</code></none></p>
<h3 id="6中间层镜像">6.中间层镜像</h3>
<p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。<br />
<code>$ docker image ls -a</code></p>
<h3 id="7列出部分镜像">7.列出部分镜像</h3>
<div><pre class="hljs"><code><span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> ubuntu
<span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> ubuntu:<span class="hljs-number">18.04</span>
<span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> <span class="hljs-operator">-f</span> since=mongo:<span class="hljs-number">3.2</span></code></pre></div>
<p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。<br />
此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。<br />
<code>$ docker image ls -f label=com.example.version=0.1</code></p>
<p>利用 docker image ls 把所有的虚悬镜像的 ID 列出来<br />
<code>$docker image ls -q</code></p>
<p>下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<div><pre class="hljs"><code><span class="hljs-string">$</span> <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">ls</span> <span class="hljs-string">--format</span> <span class="hljs-string">"<span class="hljs-template-variable">{{.ID}}</span>: <span class="hljs-template-variable">{{.Repository}}</span>"</span>
<span class="hljs-attr">5f515359c7f8:</span> <span class="hljs-string">redis</span>
<span class="hljs-attr">05a60462f8ba:</span> <span class="hljs-string">nginx</span>
<span class="hljs-attr">fe9198c04d62:</span> <span class="hljs-string">mongo</span>
<span class="hljs-attr">00285df0df87:</span> <span class="hljs-string">&lt;none&gt;</span>
<span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span>
<span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span></code></pre></div>
<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p>
<div><pre class="hljs"><code><span class="language-xml">$ docker image ls --format "table </span><span class="hljs-template-variable">{{<span class="hljs-name">.ID</span>}}</span><span class="language-xml">\t</span><span class="hljs-template-variable">{{<span class="hljs-name">.Repository</span>}}</span><span class="language-xml">\t</span><span class="hljs-template-variable">{{<span class="hljs-name">.Tag</span>}}</span><span class="language-xml">"
IMAGE ID            REPOSITORY          TAG
5f515359c7f8        redis               latest
05a60462f8ba        nginx               latest
fe9198c04d62        mongo               3.2
00285df0df87        <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>
329ed837d508        ubuntu              18.04
329ed837d508        ubuntu              bionic</span></code></pre></div>
<h3 id="8删除本地镜像">8.删除本地镜像</h3>
<p>如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：<br />
<code>$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></p>
<p><strong>用 docker image ls 命令来配合</strong><br />
像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。<br />
比如，我们需要删除所有仓库名为 redis 的镜像：<br />
<code>$ docker image rm $(docker image ls -q redis)</code><br />
或者删除所有在 mongo:3.2 之前的镜像：<br />
<code>$ docker image rm $(docker image ls -q -f before=mongo:3.2)</code></p>
<h3 id="9利用-commit-理解镜像构成">9.利用 commit 理解镜像构成</h3>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。<br />
docker commit 的语法格式为：<br />
docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]<br />
我们可以用下面的命令将容器保存为镜像：</p>
<div><pre class="hljs"><code>    --author <span class="hljs-string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> <span class="hljs-string">\</span>
    --message <span class="hljs-string">"修改了默认网页"</span> <span class="hljs-string">\</span>
    webserver <span class="hljs-string">\</span>
    nginx:v2
sha256:<span class="hljs-number">07e</span>33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</code></pre></div>
<p>其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。</p>
<h3 id="10exec-命令进入镜像">10.exec 命令进入镜像</h3>
<p>-i -t 参数<br />
docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。<br />
只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。<br />
当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。<br />
<code>$ docker run -dit ubuntu</code></p>
<h3 id="11导出容器">11.导出容器</h3>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。<br />
<code>$ docker container ls  -a</code><br />
<code>$ docker  export 7691a814370e &gt; ubuntu.tar</code><br />
这样将导出容器快照到本地文件。</p>
<h3 id="12导入容器快照">12.导入容器快照</h3>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如<br />
<code>$ cat ubuntu.tar |  docker  import - test/ubuntu:v1</code><br />
此外，也可以通过指定 URL 或者某个目录来导入，例如<br />
<code>$ docker  import http://example.com/exampleimage.tgz example/imagerepo</code><br />
<em>注：用户既可以使用</em> <code>docker load</code> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <code>docker import</code> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h3 id="13删除容器">13.删除容器</h3>
<p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如<br />
<code>$ docker container rm trusting_newton</code><br />
如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<h3 id="14清理所有处于终止状态的容器">14.清理所有处于终止状态的容器</h3>
<p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。<br />
<code>$ docker container prune</code></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[005.CentOS - Docker — 从入门到实践]]></title>
            <guid>aa1cd4c0f756490abd47ce04310b4d6e</guid>
            <pubDate>Sun, 04 Feb 2024 09:25:34 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="centos">CentOS</h2>
<p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p>
<h3 id="准备工作">准备工作</h3>
<p><strong>系统要求</strong><br />
Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br />
卸载旧版本<br />
旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<div><pre class="hljs"><code>                  docker-client <span class="hljs-string">\</span>
                  docker-client-latest <span class="hljs-string">\</span>
                  docker-common <span class="hljs-string">\</span>
                  docker-latest <span class="hljs-string">\</span>
                  docker-latest-logrotate <span class="hljs-string">\</span>
                  docker-logrotate <span class="hljs-string">\</span>
                  docker-selinux <span class="hljs-string">\</span>
                  docker-engine-selinux <span class="hljs-string">\</span>
                  docker-engine</code></pre></div>
<p>使用 yum 安装<br />
执行以下命令安装依赖包：<br />
<code>$ sudo yum install -y yum-utils</code><br />
鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。<br />
执行下面的命令添加 yum 软件源：</p>
<div><pre class="hljs"><code>$ sudo yum-config-manager \
    --add-repo \
    https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo
​
$ sudo sed -i <span class="hljs-string">'s/download.docker.com/mirrors.aliyun.com\/docker-ce/g'</span> <span class="hljs-regexp">/etc/yum</span>.repos.d/docker-ce.repo
​
<span class="hljs-comment"># 官方源</span>
<span class="hljs-comment"># $ sudo yum-config-manager \</span>
<span class="hljs-comment">#     --add-repo \</span>
<span class="hljs-comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></code></pre></div>
<p>如果需要测试版本的 Docker 请执行以下命令：<br />
<code>$ sudo yum-config-manager --enable docker-ce-test</code><br />
安装 Docker<br />
更新 yum 软件源缓存，并安装 docker-ce。<br />
<code>$ sudo yum install docker-ce docker-ce-cli containerd.io</code><br />
CentOS8 额外设置<br />
由于 CentOS8 防火墙使用了 nftables，但 Docker 尚未支持 nftables， 我们可以使用如下设置使用 iptables：<br />
更改 /etc/firewalld/firewalld.conf<br />
<code># FirewallBackend=nftables FirewallBackend=iptables 或者执行如下命令： $ firewall-cmd --permanent --zone=trusted --add-interface=docker0 ​ $ firewall-cmd --reload </code><br />
使用脚本自动安装<br />
在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装：<br />
若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p>
<div><pre class="hljs"><code><span class="hljs-comment"># $ curl -fsSL test.docker.com -o get-docker.sh</span>
$ <span class="hljs-string">curl</span> -<span class="hljs-string">fsSL</span> <span class="hljs-string">get</span>.<span class="hljs-string">docker</span>.<span class="hljs-string">com</span> -<span class="hljs-string">o</span> <span class="hljs-built_in">get-docker.sh</span>
$ <span class="hljs-string">sudo</span> <span class="hljs-string">sh</span> <span class="hljs-built_in">get-docker.sh</span> <span class="hljs-built_in">--mirror</span> <span class="hljs-string">Aliyun</span>
<span class="hljs-comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></code></pre></div>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。<br />
启动 Docker</p>
<div><pre class="hljs"><code><span class="hljs-variable">$</span> sudo systemctl enable docker
<span class="hljs-variable">$</span> sudo systemctl <span class="hljs-built_in">start</span> docker</code></pre></div>
<p>建立 docker 用户组<br />
默认情况下，docker 命令会使用  与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。<br />
建立 docker 组：<br />
<code>$ sudo groupadd docker</code><br />
将当前用户加入 docker 组：<br />
<code>$ sudo usermod -aG docker $USER</code><br />
退出当前终端并重新登录，进行如下测试。<br />
测试 Docker 是否安装正确</p>
<div><pre class="hljs"><code>$ docker run <span class="hljs-comment">--rm hello-world</span>
​
Unable <span class="hljs-built_in">to</span> find image <span class="hljs-string">'hello-world:latest'</span> locally
latest: Pulling <span class="hljs-built_in">from</span> library/hello-world
b8dfde127a29: Pull complete
Digest: sha256:<span class="hljs-number">308866</span>a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24
Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest
​
Hello <span class="hljs-built_in">from</span> Docker!
This message shows that your installation appears <span class="hljs-built_in">to</span> be working correctly.
​
To generate this message, Docker took <span class="hljs-keyword">the</span> following steps:
 <span class="hljs-number">1.</span> The Docker client contacted <span class="hljs-keyword">the</span> Docker daemon.
 <span class="hljs-number">2.</span> The Docker daemon pulled <span class="hljs-keyword">the</span> <span class="hljs-string">"hello-world"</span> image <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> Docker Hub.
    (amd64)
 <span class="hljs-number">3.</span> The Docker daemon created <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> container <span class="hljs-built_in">from</span> that image which runs <span class="hljs-keyword">the</span>
    executable that produces <span class="hljs-keyword">the</span> output you are currently reading.
 <span class="hljs-number">4.</span> The Docker daemon streamed that output <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Docker client, which sent <span class="hljs-keyword">it</span>
    <span class="hljs-built_in">to</span> your terminal.
​
To <span class="hljs-keyword">try</span> something more ambitious, you can run <span class="hljs-keyword">an</span> Ubuntu container <span class="hljs-keyword">with</span>:
 $ docker run -<span class="hljs-keyword">it</span> ubuntu bash
​
Share images, automate workflows, <span class="hljs-keyword">and</span> more <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> free Docker ID:
 <span class="hljs-keyword">https</span>://hub.docker.com/
​
For more examples <span class="hljs-keyword">and</span> ideas, visit:
 <span class="hljs-keyword">https</span>://docs.docker.com/<span class="hljs-built_in">get</span>-started/</code></pre></div>
<p>若能正常输出以上信息，则说明安装成功。<br />
镜像加速<br />
如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 。<br />
添加内核参数<br />
如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p>
<div><pre class="hljs"><code><span class="hljs-symbol">WARNING: </span>bridge-nf-call-iptables is disabled
<span class="hljs-symbol">WARNING: </span>bridge-nf-call-ip6tables is disabled</code></pre></div>
<p>请添加内核配置参数以启用这些功能。</p>
<div><pre class="hljs"><code>$ sudo tee -<span class="hljs-selector-tag">a</span> /etc/sysctl<span class="hljs-selector-class">.conf</span> &lt;&lt;-EOF
net<span class="hljs-selector-class">.bridge</span><span class="hljs-selector-class">.bridge-nf-call-ip6tables</span> = <span class="hljs-number">1</span>
net<span class="hljs-selector-class">.bridge</span><span class="hljs-selector-class">.bridge-nf-call-iptables</span> = <span class="hljs-number">1</span>
EOF</code></pre></div>
<p>然后重新加载 sysctl.conf 即可<br />
<code>$ sudo sysctl -p</code></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[00019.xargs命令]]></title>
            <guid>3a3414badbd142abbdb47a2786d2540a</guid>
            <pubDate>Tue, 23 Jan 2024 03:13:53 GMT</pubDate>
            <content:encoded><![CDATA[<p>例子：</p>
<h1 id="中控机执行命令">中控机执行命令</h1>
<p>echo bkssm bkiam usermgr paas cmdb gse job consul bklog | xargs -n 1 ./bkcli check</p>
<p>详解：<br />
xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。<br />
xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。<br />
xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。<br />
xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。<br />
xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。<br />
之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：<br />
find /sbin -perm +700 |ls -l       #这个命令是错误的<br />
find /sbin -perm +700 |xargs ls -l   #这样才是正确的<br />
xargs 一般是和管道一起使用。<br />
命令格式：<br />
somecommand |xargs -item  command<br />
参数：<br />
-a file 从文件中读入作为 stdin<br />
-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。<br />
-p 当每次执行一个argument的时候询问一次用户。<br />
-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。<br />
-t 表示先打印命令，然后再执行。<br />
-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。<br />
-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。<br />
-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。<br />
-L num 从标准输入一次读取 num 行送给 command 命令。<br />
-l 同 -L。<br />
-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。<br />
-x exit的意思，主要是配合-s使用。。<br />
-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。<br />
实例<br />
xargs 用作替换工具，读取输入数据重新格式化后输出。<br />
定义一个测试文件，内有多行文本数据：</p>
<h1 id="cat-testtxt">cat test.txt</h1>
<p>a b c d e f g<br />
h i j k l m n<br />
o p q<br />
r s t<br />
u v w x y z<br />
多行输入单行输出：</p>
<h1 id="cat-testtxt-xargs">cat test.txt | xargs</h1>
<p>a b c d e f g h i j k l m n o p q r s t u v w x y z<br />
-n 选项多行输出：</p>
<h1 id="cat-testtxt-xargs-n3">cat test.txt | xargs -n3</h1>
<p>a b c<br />
d e f<br />
g h i<br />
j k l<br />
m n o<br />
p q r<br />
s t u<br />
v w x<br />
y z<br />
-d 选项可以自定义一个定界符：</p>
<h1 id="echo-namexnamexnamexname-xargs-dx">echo "nameXnameXnameXname" | xargs -dX</h1>
<p>name name name name<br />
结合 -n 选项使用：</p>
<h1 id="echo-namexnamexnamexname-xargs-dx-n2">echo "nameXnameXnameXname" | xargs -dX -n2</h1>
<p>name name<br />
name name<br />
读取 stdin，将格式化后的参数传递给命令<br />
假设一个命令为 sk.sh 和一个保存参数的文件 arg.txt：<br />
#!/bin/bash<br />
#sk.sh命令内容，打印出所有参数。</p>
<p>echo $*<br />
arg.txt文件内容：</p>
<h1 id="cat-argtxt">cat arg.txt</h1>
<p>aaa<br />
bbb<br />
ccc<br />
xargs 的一个选项 -I，使用 -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次：</p>
<h1 id="cat-argtxt-xargs-i-sksh-p-l">cat arg.txt | xargs -I {} ./sk.sh -p {} -l</h1>
<p>-p aaa -l<br />
-p bbb -l<br />
-p ccc -l<br />
复制所有图片文件到 /data/images 目录下：<br />
ls <em>.jpg | xargs -n1 -I {} cp {} /data/images<br />
xargs 结合 find 使用<br />
用 rm 删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too long. 用 xargs 去避免这个问题：<br />
find . -type f -name "</em>.log" -print0 | xargs -0 rm -f<br />
xargs -0 将 \0 作为定界符。<br />
统计一个源代码目录中所有 php 文件的行数：<br />
find . -type f -name "<em>.php" -print0 | xargs -0 wc -l<br />
查找所有的 jpg 文件，并且压缩它们：<br />
find . -type f -name "</em>.jpg" -print | xargs tar -czvf images.tar.gz<br />
xargs 其他应用<br />
假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接：</p>
<h1 id="cat-url-listtxt-xargs-wget-c">cat url-list.txt | xargs wget -c</h1>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[00004.lsof用法]]></title>
            <guid>a708c849e49b48f9b310a9e094198b65</guid>
            <pubDate>Thu, 18 Jan 2024 00:55:35 GMT</pubDate>
            <content:encoded><![CDATA[<p>lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，用户通过文件不仅可以访问常规数据，还可以访问网络连接和硬件；如传输控制协议 (TCP) 和用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于此应用程序的信息。本期，ISEC实验室的刘老师为大家详解lsof的用法。</p>
<p>一、命令参数</p>
<p>-a：列出打开文件存在的进程；</p>
<p>-c&lt;进程名&gt;：列出指定进程所打开的文件；</p>
<p>-g：列出GID号进程详情；</p>
<p>-d&lt;文件号&gt;：列出占用该文件号的进程；</p>
<p>+d&lt;目录&gt;：列出目录下被打开的文件；</p>
<p>+D&lt;目录&gt;：递归列出目录下被打开的文件；</p>
<p>-n&lt;目录&gt;：列出使用NFS的文件；</p>
<p>-i&lt;条件&gt;：列出符合条件的进程(4、6、协议、:端口、 @ip )；</p>
<p>-p&lt;进程号&gt;：列出指定进程号所打开的文件；</p>
<p>-u：列出UID号进程详情；</p>
<p>-h：显示帮助信息；</p>
<p>-v：显示版本信息。</p>
<p>二、实例讲解</p>
<p><img src="/_resources/75610d82c3d44613849c5f7d741c24ae.png" /></p>
<p>1、lsof输出各列信息的意义，如下：</p>
<p>COMMAND：进程的名称；</p>
<p>PID：进程标识符；</p>
<p>PPID：父进程标识符(需要指定-R参数)；</p>
<p>USER：进程所有者；</p>
<p>PGID：进程所属组；</p>
<p>FD：文件描述符，应用程序通过文件描述符识别该文件。</p>
<p>2、文件描述符列表：</p>
<p>①. cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改；</p>
<p>②. txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序；</p>
<p>③. lnn：library references (AIX)；</p>
<p>④. er：FD information error (see NAME column)；</p>
<p>⑤. jld：jail directory (FreeBSD)；</p>
<p>⑥. ltx：shared library text (code and data)；</p>
<p>⑦. mxx ：hex memory-mapped type number xx.</p>
<p>⑧. m86：DOS Merge mapped file；</p>
<p>⑨. mem：memory-mapped file；</p>
<p>⑩. mmap：memory-mapped device；</p>
<p>. pd：parent directory；</p>
<p>. rtd：root directory；</p>
<p>. tr：kernel trace file (OpenBSD)；</p>
<p>. v86 VP/ix mapped file；</p>
<p>. 0：表示标准输出；</p>
<p>. 1：表示标准输入；</p>
<p>. 2：表示标准错误。</p>
<p>3、一般在标准输出、标准错误、标准输入后，还跟着文件状态模式：</p>
<p>①.u：表示该文件被打开并处于读取/写入模式；</p>
<p>②.r：表示该文件被打开并处于只读模式；</p>
<p>③.w：表示该文件被打开并处于只写模式；</p>
<p>④.空格：表示该文件的状态模式为unknow，且没有锁定；</p>
<p>⑤.-：表示该文件的状态模式为unknow，且被锁定。</p>
<p>4、同时在文件状态模式后面，还跟着相关的锁：</p>
<p>①. N：for a Solaris NFS lock of unknown type；</p>
<p>②. r：for read lock on part of the file；</p>
<p>③. R：for a read lock on the entire file；</p>
<p>④. w：for a write lock on part of the file；(文件的部分写锁)</p>
<p>⑤. W：for a write lock on the entire file；(整个文件的写锁)</p>
<p>⑥. u：for a read and write lock of any length；</p>
<p>⑦. U：for a lock of unknown type；</p>
<p>⑧. x：for an SCO OpenServer Xenix lock on part of the file；</p>
<p>⑨. X：for an SCO OpenServer Xenix lock on the entire file；</p>
<p>⑩. space：if there is no lock。</p>
<p>5、文件类型</p>
<p>①. DIR：表示目录；</p>
<p>②. CHR：表示字符类型；</p>
<p>③. BLK：块设备类型；</p>
<p>④. UNIX：UNIX 域套接字；</p>
<p>⑤. FIFO：先进先出 (FIFO) 队列；</p>
<p>⑥. IPv4：网际协议 (IP) 套接字；</p>
<p>⑦. DEVICE：指定磁盘的名称；</p>
<p>⑧. SIZE：文件的大小；</p>
<p>⑨. NODE：索引节点(文件在磁盘上的标识)；</p>
<p>⑩. NAME：打开文件的确切名称。</p>
<p>三、可打开文件</p>
<p>①. 普通文件；</p>
<p>②. 目录；</p>
<p>③. 网络文件系统的文件；</p>
<p>④. 字符或设备文件；</p>
<p>⑤. (函数)共享库；</p>
<p>⑥. 管道，命名管道；</p>
<p>⑦. 符号链接；</p>
<p>⑧. 网络文件(例如：NFS file、网络socket，unix域名socket)；</p>
<p>⑨. 其它类型的文件等。</p>
<p>四、常规用法</p>
<p>lsof 常被用来查找应用程序打开的文件名称和数目，系统管理员可能想尝试找出某个特定应用程序将日志数据记录到何处，或者正在跟踪某个问题。接下来，我们来看看是如何操作的：</p>
<p>1、进程篇</p>
<p>(1)、查看由登陆用户启动而非系统启动的进程：</p>
<p>命令： lsof /dev/pts0<br />
<img src="/_resources/2d4b712ed5fd4fdfbebc428d23460617.png" /></p>
<p>a. /dev/pts是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录；</p>
<p>b. 第一个用户登陆，console的设备文件为/dev/pts/0，第二个为/dev/pts/1，以此类推；</p>
<p>c. 通过查看/dev/pts下的进程，我们将可以了解到由登陆用户启动而非系统启动的进程有哪些。</p>
<p>(2)、查看文件，设备被哪些进程占用：</p>
<p>命令：lsof /dev/tty1</p>
<p><img src="/_resources/82de2d48d0f5415687cb2f321bafe71a.png" /></p>
<p>a. /dev/tty就是当前进程的控制终端的设备特殊文件；</p>
<p>b. 通过查看/dev/tty下文件可以知道文件、设备的进程占用情况。</p>
<p>(3)、指定进程号，可以查看该进程打开的文件：</p>
<p>命令：lsof -p 27358<br />
<img src="/_resources/a7d25645610741069caba7553c709fe2.png" /><br />
a. 通过加入参数-p，我们可以指定一个PID，然后查看该进程下打开的文件。</p>
<p>b. 本例我们查看的是nginx下打开的相关文件。</p>
<p>2、文件篇</p>
<p>(1)、查看指定程序打开的文件</p>
<p>命令：lsof -c sshd<br />
<img src="/_resources/fd4391ae7e584c098bc1deaa5236422e.png" /><br />
通过参数-c可以列出指定进程所打开的文件情况，以上是我们打开sshd下被打开文件的情况。</p>
<p>(2)、查看指定用户打开的文件</p>
<p>命令：lsof -u root | more</p>
<p><img src="/_resources/f7b13316c2a241d7a0038417dcf0c129.png" /></p>
<p>通过参数-u查看root用户下存在的文件情况，由于root下显示内容较多，可以利用more来限制，进行分页查看。</p>
<p>(3)、查看指定目录下被打开的文件</p>
<p>命令：lsof +D /home/ 或lsof +d /home/</p>
<p><img src="/_resources/8acadd009f97488684321d30eecb251c.png" /></p>
<p>参数+D为递归列出/home/下被打开的文件，参数+d为列出/home/下被打开的文件。</p>
<p>3、网络篇</p>
<p>(1)、查看所有网络连接</p>
<p>命令：lsof -i 和 lsof -i@127.0.0.1　　<br />
<img src="/_resources/3d8ee1ed8fad410ab36f76600d9f58de.png" /><br />
<img src="/_resources/e59736e9384f4b5d9102983235ca593b.png" /></p>
<p>通过参数-i查看网络连接的情况，包括连接的ip、端口等；以及一些服务的连接情况，例如：sshd等。也可以通过指定ip查看该ip的网络连接情况。</p>
<p>(2)、查看端口连接情况</p>
<p>命令：lsof -i :22<br />
<img src="/_resources/3bc95b57a05e4694b481513b8e7f1333.png" /></p>
<p>通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等。</p>
<p>4、综合篇</p>
<p>(1)、查看指定进程打开的网络连接</p>
<p>命令：lsof -i -a -p 1535</p>
<p><img src="/_resources/a287934cd706491284fefcac2f726b9a.png" /></p>
<p>使用了参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进程。</p>
<p>(2)、查看指定状态的网络连接</p>
<p>命令：lsof -n -P -i TCP -s TCP:ESTABLISHED</p>
<p><img src="/_resources/4a1d814e9a744a8eaa5332dc138ccb58.png" /></p>
<p>参数解释： -n:no host names, -P:no port names,-i TCP指定协议，-s指定协议状态；通过多个参数我们可以清晰的查看网络连接情况、协议连接情况等。</p>
<p>五、恢复被删除的日志</p>
<p>Linux的系统日志默认保存在/var/log下<br />
<img src="/_resources/b140ba0f5c8f447bb2857cb38b8c6506.png" /></p>
<p>当Linux系统被入侵后，很多入侵者经常会删除系统中的各种日志，包括Web的access和error日志、last日志、messages日志、secure日志等，阻碍应急响应和取证调查，比如rm -rf /var/log。</p>
<p><img src="/_resources/03d4adef27be4b3da9e56c6f6fb2a6b2.png" /></p>
<p>遇到这种情况，不要关闭或者重启服务器系统，也不要关闭或重启相关服务或者进程，如：恢复apache的访问日志/var/log/httpd/access_log时，不能关闭或者重启服务器系统，也不能重启httpd服务。</p>
<p>假设我们要恢复被删除的messages日志和secure日志：</p>
<p>1.首先通过losf命令找到使用messages文件的进程的PID和messages文件的FD(文件描述符)；<br />
<img src="/_resources/34f002b904f14f88a1e2578cf872da5b.png" /></p>
<p>从上面命令输出可以看到，这个打开/var/log/messages文件的进程的PID是815，文件/var/log/messages的FD(文件描述符)是4，状态为deleted，标记被删除，但其实该文件并没有从磁盘中删除。</p>
<p>2.如果删除的文件还存在操作的进程，数据将可能被找回，可以在/proc/815/fd/4找到被删除的/var/log/messages文件；</p>
<p><img src="/_resources/4527d233a84f4335a921a32883cea4ee.png" /></p>
<p><img src="/_resources/3c90506ddfc34a14b821daa48e2299c2.png" /></p>
<p>3.恢复被删除的/var/log/secure文件；</p>
<p><img src="/_resources/3ca870a5bc334972b09e2da7d27a5c89.png" /></p>
<p>在Linux系统中删除了一个文件，只要进程还在对文件进行操作，就可能还存在一个inode的引用：/proc/进程号/fd/文件描述符，只要知道当前打开文件的进程pid和文件描述符fd，即可利用lsof命令还原出被删除的文件。</p>
<p>六、总 结</p>
<p>Linux大量使用了文件，作为系统管理员，lsof 允许用户对核心内存进行查看，以找出系统当前如何使用这些文件。lsof的简单用法可以告诉用户哪些进程打开了哪些文件，以及哪些文件由哪些进程打开。</p>
<p>在收集关于应用程序工作情况的信息时，或在进行某些可能损坏数据的操作前，要确保文件未被使用，这一点特别重要。lsof 更高级的用法可以帮助用户查找删除的文件，并获得关于网络连接的信息。lsof 是一个功能强大的工具，它几乎可以用于任何地方。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[0001.linux指标文件]]></title>
            <guid>3e28a2f929a74585af8eb52a74ba7aed</guid>
            <pubDate>Wed, 17 Jan 2024 00:24:30 GMT</pubDate>
            <content:encoded><![CDATA[<p>1.CPU指标获取<br />
解析 /proc/stat ，获取 user、nice、sys、irq、softirq、steal、guest、guestnice、idle、iowait<br />
2.CPU负载获取<br />
Linux /proc/loadavg 文件内容如下</p>
<blockquote>
<p>cat /proc/loadavg<br />
4.61 4.36 4.15 9/84 5662<br />
lavg_1 (4.61) 1 分钟平均负载<br />
lavg_5 (4.36) 5 分钟平均负载<br />
lavg_15(4.15) 15 分钟平均负载<br />
nr_running (9) 在采样时刻，运行队列的任务的数目，与 /proc/stat 的 procs_running 表示相同意思<br />
nr_threads (84) 在采样时刻，系统中活跃的任务的个数（不包括运行已经结束的任务）<br />
last_pid(5662) 最大的 pid 值，包括轻量级进程，即线程。<br />
3.磁盘信息获取<br />
解析 /proc/diskstats<br />
4.memory信息查询<br />
解析 /proc/meminfo 文件获取内存信息并且解析出 MemTotal 字段即为物理内存总大小<br />
5.网卡信息<br />
解析 /proc/net/dev 文件获取网卡相关的信息，相关信息如下 - 接收端：bytes、packets、errs、drop、fifo、frame、compressed、multicast - 发送端：bytes、packets、errs、drop、fifo、colls、carrier、compressed - 单位时间内获取两次接收端的 packets 的值</p>
</blockquote>
]]></content:encoded>
        </item>
    </channel>
</rss>